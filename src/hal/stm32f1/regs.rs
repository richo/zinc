// Zinc, the bare metal stack for rust.
// Copyright 2015 zinc developers <http://zinc.rs>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY IT DIRECTLY, UPDATE THE
// SVD DEFINITION IN SUPPORT/SVD/DATA AND RE-GENERATE, ADDING THE CHANGES MADE
// INTO THE RELEVANT CHANGELOG ENTRY.

//! ioregs definition based on data/STMicro/STM32F103xx.xml

use volatile_cell::VolatileCell;
use core::ops::Drop;

ioregs! (FSMC @ 0xa0000000 = {  //! Flexible static memory controller
  0x00 => reg32 bcr1 {  //! SRAM/NOR-Flash chip-select control register           1
    19 => cburstrw,  //= CBURSTRW
    15 => asyncwait,  //= ASYNCWAIT
    14 => extmod,  //= EXTMOD
    13 => waiten,  //= WAITEN
    12 => wren,  //= WREN
    11 => waitcfg,  //= WAITCFG
    9 => waitpol,  //= WAITPOL
    8 => bursten,  //= BURSTEN
    6 => faccen,  //= FACCEN
    5..4 => mwid,  //= MWID
    3..2 => mtyp,  //= MTYP
    1 => muxen,  //= MUXEN
    0 => mbken,  //= MBKEN
  },
  0x04 => reg32 btr1 {  //! SRAM/NOR-Flash chip-select timing register           1
    29..28 => accmod,  //= ACCMOD
    27..24 => datlat,  //= DATLAT
    23..20 => clkdiv,  //= CLKDIV
    19..16 => busturn,  //= BUSTURN
    15..8 => datast,  //= DATAST
    7..4 => addhld,  //= ADDHLD
    3..0 => addset,  //= ADDSET
  },
  0x08 => reg32 bcr2 {  //! SRAM/NOR-Flash chip-select control register           2
    19 => cburstrw,  //= CBURSTRW
    15 => asyncwait,  //= ASYNCWAIT
    14 => extmod,  //= EXTMOD
    13 => waiten,  //= WAITEN
    12 => wren,  //= WREN
    11 => waitcfg,  //= WAITCFG
    10 => wrapmod,  //= WRAPMOD
    9 => waitpol,  //= WAITPOL
    8 => bursten,  //= BURSTEN
    6 => faccen,  //= FACCEN
    5..4 => mwid,  //= MWID
    3..2 => mtyp,  //= MTYP
    1 => muxen,  //= MUXEN
    0 => mbken,  //= MBKEN
  },
  0x0c => reg32 btr2 {  //! SRAM/NOR-Flash chip-select timing register           2
    29..28 => accmod,  //= ACCMOD
    27..24 => datlat,  //= DATLAT
    23..20 => clkdiv,  //= CLKDIV
    19..16 => busturn,  //= BUSTURN
    15..8 => datast,  //= DATAST
    7..4 => addhld,  //= ADDHLD
    3..0 => addset,  //= ADDSET
  },
  0x10 => reg32 bcr3 {  //! SRAM/NOR-Flash chip-select control register           3
    19 => cburstrw,  //= CBURSTRW
    15 => asyncwait,  //= ASYNCWAIT
    14 => extmod,  //= EXTMOD
    13 => waiten,  //= WAITEN
    12 => wren,  //= WREN
    11 => waitcfg,  //= WAITCFG
    10 => wrapmod,  //= WRAPMOD
    9 => waitpol,  //= WAITPOL
    8 => bursten,  //= BURSTEN
    6 => faccen,  //= FACCEN
    5..4 => mwid,  //= MWID
    3..2 => mtyp,  //= MTYP
    1 => muxen,  //= MUXEN
    0 => mbken,  //= MBKEN
  },
  0x14 => reg32 btr3 {  //! SRAM/NOR-Flash chip-select timing register           3
    29..28 => accmod,  //= ACCMOD
    27..24 => datlat,  //= DATLAT
    23..20 => clkdiv,  //= CLKDIV
    19..16 => busturn,  //= BUSTURN
    15..8 => datast,  //= DATAST
    7..4 => addhld,  //= ADDHLD
    3..0 => addset,  //= ADDSET
  },
  0x18 => reg32 bcr4 {  //! SRAM/NOR-Flash chip-select control register           4
    19 => cburstrw,  //= CBURSTRW
    15 => asyncwait,  //= ASYNCWAIT
    14 => extmod,  //= EXTMOD
    13 => waiten,  //= WAITEN
    12 => wren,  //= WREN
    11 => waitcfg,  //= WAITCFG
    10 => wrapmod,  //= WRAPMOD
    9 => waitpol,  //= WAITPOL
    8 => bursten,  //= BURSTEN
    6 => faccen,  //= FACCEN
    5..4 => mwid,  //= MWID
    3..2 => mtyp,  //= MTYP
    1 => muxen,  //= MUXEN
    0 => mbken,  //= MBKEN
  },
  0x1c => reg32 btr4 {  //! SRAM/NOR-Flash chip-select timing register           4
    29..28 => accmod,  //= ACCMOD
    27..24 => datlat,  //= DATLAT
    23..20 => clkdiv,  //= CLKDIV
    19..16 => busturn,  //= BUSTURN
    15..8 => datast,  //= DATAST
    7..4 => addhld,  //= ADDHLD
    3..0 => addset,  //= ADDSET
  },
  0x60 => reg32 pcr2 {  //! PC Card/NAND Flash control register           2
    19..17 => eccps,  //= ECCPS
    16..13 => tar,  //= TAR
    12..9 => tclr,  //= TCLR
    6 => eccen,  //= ECCEN
    5..4 => pwid,  //= PWID
    3 => ptyp,  //= PTYP
    2 => pbken,  //= PBKEN
    1 => pwaiten,  //= PWAITEN
  },
  0x64 => reg32 sr2 {  //! FIFO status and interrupt register           2
    6 => fempt: ro,  //= FEMPT
    5 => ifen,  //= IFEN
    4 => ilen,  //= ILEN
    3 => iren,  //= IREN
    2 => ifs,  //= IFS
    1 => ils,  //= ILS
    0 => irs,  //= IRS
  },
  0x68 => reg32 pmem2 {  //! Common memory space timing register           2
    31..24 => memhizx,  //= MEMHIZx
    23..16 => memholdx,  //= MEMHOLDx
    15..8 => memwaitx,  //= MEMWAITx
    7..0 => memsetx,  //= MEMSETx
  },
  0x6c => reg32 patt2 {  //! Attribute memory space timing register           2
    31..24 => atthizx,  //= Attribute memory x databus HiZ               time
    23..16 => attholdx,  //= Attribute memory x hold               time
    15..8 => attwaitx,  //= Attribute memory x wait               time
    7..0 => attsetx,  //= Attribute memory x setup               time
  },
  0x74 => reg32 eccr2 {  //! ECC result register 2
    31..0 => eccx: ro,  //= ECC result
  },
  0x80 => reg32 pcr3 {  //! PC Card/NAND Flash control register           3
    19..17 => eccps,  //= ECCPS
    16..13 => tar,  //= TAR
    12..9 => tclr,  //= TCLR
    6 => eccen,  //= ECCEN
    5..4 => pwid,  //= PWID
    3 => ptyp,  //= PTYP
    2 => pbken,  //= PBKEN
    1 => pwaiten,  //= PWAITEN
  },
  0x84 => reg32 sr3 {  //! FIFO status and interrupt register           3
    6 => fempt: ro,  //= FEMPT
    5 => ifen,  //= IFEN
    4 => ilen,  //= ILEN
    3 => iren,  //= IREN
    2 => ifs,  //= IFS
    1 => ils,  //= ILS
    0 => irs,  //= IRS
  },
  0x88 => reg32 pmem3 {  //! Common memory space timing register           3
    31..24 => memhizx,  //= MEMHIZx
    23..16 => memholdx,  //= MEMHOLDx
    15..8 => memwaitx,  //= MEMWAITx
    7..0 => memsetx,  //= MEMSETx
  },
  0x8c => reg32 patt3 {  //! Attribute memory space timing register           3
    31..24 => atthizx,  //= ATTHIZx
    23..16 => attholdx,  //= ATTHOLDx
    15..8 => attwaitx,  //= ATTWAITx
    7..0 => attsetx,  //= ATTSETx
  },
  0x94 => reg32 eccr3 {  //! ECC result register 3
    31..0 => eccx: ro,  //= ECCx
  },
  0xa0 => reg32 pcr4 {  //! PC Card/NAND Flash control register           4
    19..17 => eccps,  //= ECCPS
    16..13 => tar,  //= TAR
    12..9 => tclr,  //= TCLR
    6 => eccen,  //= ECCEN
    5..4 => pwid,  //= PWID
    3 => ptyp,  //= PTYP
    2 => pbken,  //= PBKEN
    1 => pwaiten,  //= PWAITEN
  },
  0xa4 => reg32 sr4 {  //! FIFO status and interrupt register           4
    6 => fempt: ro,  //= FEMPT
    5 => ifen,  //= IFEN
    4 => ilen,  //= ILEN
    3 => iren,  //= IREN
    2 => ifs,  //= IFS
    1 => ils,  //= ILS
    0 => irs,  //= IRS
  },
  0xa8 => reg32 pmem4 {  //! Common memory space timing register           4
    31..24 => memhizx,  //= MEMHIZx
    23..16 => memholdx,  //= MEMHOLDx
    15..8 => memwaitx,  //= MEMWAITx
    7..0 => memsetx,  //= MEMSETx
  },
  0xac => reg32 patt4 {  //! Attribute memory space timing register           4
    31..24 => atthizx,  //= ATTHIZx
    23..16 => attholdx,  //= ATTHOLDx
    15..8 => attwaitx,  //= ATTWAITx
    7..0 => attsetx,  //= ATTSETx
  },
  0xb0 => reg32 pio4 {  //! I/O space timing register 4
    31..24 => iohizx,  //= IOHIZx
    23..16 => ioholdx,  //= IOHOLDx
    15..8 => iowaitx,  //= IOWAITx
    7..0 => iosetx,  //= IOSETx
  },
  0x104 => reg32 bwtr1 {  //! SRAM/NOR-Flash write timing registers           1
    29..28 => accmod,  //= ACCMOD
    27..24 => datlat,  //= DATLAT
    23..20 => clkdiv,  //= CLKDIV
    15..8 => datast,  //= DATAST
    7..4 => addhld,  //= ADDHLD
    3..0 => addset,  //= ADDSET
  },
  0x10c => reg32 bwtr2 {  //! SRAM/NOR-Flash write timing registers           2
    29..28 => accmod,  //= ACCMOD
    27..24 => datlat,  //= DATLAT
    23..20 => clkdiv,  //= CLKDIV
    15..8 => datast,  //= DATAST
    7..4 => addhld,  //= ADDHLD
    3..0 => addset,  //= ADDSET
  },
  0x114 => reg32 bwtr3 {  //! SRAM/NOR-Flash write timing registers           3
    29..28 => accmod,  //= ACCMOD
    27..24 => datlat,  //= DATLAT
    23..20 => clkdiv,  //= CLKDIV
    15..8 => datast,  //= DATAST
    7..4 => addhld,  //= ADDHLD
    3..0 => addset,  //= ADDSET
  },
  0x11c => reg32 bwtr4 {  //! SRAM/NOR-Flash write timing registers           4
    29..28 => accmod,  //= ACCMOD
    27..24 => datlat,  //= DATLAT
    23..20 => clkdiv,  //= CLKDIV
    15..8 => datast,  //= DATAST
    7..4 => addhld,  //= ADDHLD
    3..0 => addset,  //= ADDSET
  },
});
ioregs! (PWR @ 0x40007000 = {  //! Power control
  0x00 => reg32 cr {  //! Power control register           (PWR_CR)
    0 => lpds,  //= Low Power Deep Sleep
    1 => pdds,  //= Power Down Deep Sleep
    2 => cwuf,  //= Clear Wake-up Flag
    3 => csbf,  //= Clear STANDBY Flag
    4 => pvde,  //= Power Voltage Detector               Enable
    7..5 => pls,  //= PVD Level Selection
    8 => dbp,  //= Disable Backup Domain write               protection
  },
  0x04 => reg32 csr {  //! Power control register           (PWR_CR)
    0 => wuf: ro,  //= Wake-Up Flag
    1 => sbf: ro,  //= STANDBY Flag
    2 => pvdo: ro,  //= PVD Output
    8 => ewup,  //= Enable WKUP pin
  },
});
ioregs! (RCC @ 0x40021000 = {  //! Reset and clock control
  0x00 => reg32 cr {  //! Clock control register
    0 => hsion,  //= Internal High Speed clock               enable
    1 => hsirdy: ro,  //= Internal High Speed clock ready               flag
    7..3 => hsitrim,  //= Internal High Speed clock               trimming
    15..8 => hsical: ro,  //= Internal High Speed clock               Calibration
    16 => hseon,  //= External High Speed clock               enable
    17 => hserdy: ro,  //= External High Speed clock ready               flag
    18 => hsebyp,  //= External High Speed clock               Bypass
    19 => csson,  //= Clock Security System               enable
    24 => pllon,  //= PLL enable
    25 => pllrdy: ro,  //= PLL clock ready flag
  },
  0x04 => reg32 cfgr {  //! Clock configuration register           (RCC_CFGR)
    1..0 => sw,  //= System clock Switch
    3..2 => sws: ro,  //= System Clock Switch Status
    7..4 => hpre,  //= AHB prescaler
    10..8 => ppre1,  //= APB Low speed prescaler               (APB1)
    13..11 => ppre2,  //= APB High speed prescaler               (APB2)
    15..14 => adcpre,  //= ADC prescaler
    16 => pllsrc,  //= PLL entry clock source
    17 => pllxtpre,  //= HSE divider for PLL entry
    21..18 => pllmul,  //= PLL Multiplication Factor
    22 => otgfspre,  //= USB OTG FS prescaler
    26..24 => mco,  //= Microcontroller clock               output
  },
  0x08 => reg32 cir {  //! Clock interrupt register           (RCC_CIR)
    0 => lsirdyf: ro,  //= LSI Ready Interrupt flag
    1 => lserdyf: ro,  //= LSE Ready Interrupt flag
    2 => hsirdyf: ro,  //= HSI Ready Interrupt flag
    3 => hserdyf: ro,  //= HSE Ready Interrupt flag
    4 => pllrdyf: ro,  //= PLL Ready Interrupt flag
    7 => cssf: ro,  //= Clock Security System Interrupt               flag
    8 => lsirdyie,  //= LSI Ready Interrupt Enable
    9 => lserdyie,  //= LSE Ready Interrupt Enable
    10 => hsirdyie,  //= HSI Ready Interrupt Enable
    11 => hserdyie,  //= HSE Ready Interrupt Enable
    12 => pllrdyie,  //= PLL Ready Interrupt Enable
    16 => lsirdyc: wo,  //= LSI Ready Interrupt Clear
    17 => lserdyc: wo,  //= LSE Ready Interrupt Clear
    18 => hsirdyc: wo,  //= HSI Ready Interrupt Clear
    19 => hserdyc: wo,  //= HSE Ready Interrupt Clear
    20 => pllrdyc: wo,  //= PLL Ready Interrupt Clear
    23 => cssc: wo,  //= Clock security system interrupt               clear
  },
  0x0c => reg32 apb2rstr {  //! APB2 peripheral reset register           (RCC_APB2RSTR)
    0 => afiorst,  //= Alternate function I/O               reset
    2 => ioparst,  //= IO port A reset
    3 => iopbrst,  //= IO port B reset
    4 => iopcrst,  //= IO port C reset
    5 => iopdrst,  //= IO port D reset
    6 => ioperst,  //= IO port E reset
    7 => iopfrst,  //= IO port F reset
    8 => iopgrst,  //= IO port G reset
    9 => adc1rst,  //= ADC 1 interface reset
    10 => adc2rst,  //= ADC 2 interface reset
    11 => tim1rst,  //= TIM1 timer reset
    12 => spi1rst,  //= SPI 1 reset
    13 => tim8rst,  //= TIM8 timer reset
    14 => usart1rst,  //= USART1 reset
    15 => adc3rst,  //= ADC 3 interface reset
    19 => tim9rst,  //= TIM9 timer reset
    20 => tim10rst,  //= TIM10 timer reset
    21 => tim11rst,  //= TIM11 timer reset
  },
  0x10 => reg32 apb1rstr {  //! APB1 peripheral reset register           (RCC_APB1RSTR)
    0 => tim2rst,  //= Timer 2 reset
    1 => tim3rst,  //= Timer 3 reset
    2 => tim4rst,  //= Timer 4 reset
    3 => tim5rst,  //= Timer 5 reset
    4 => tim6rst,  //= Timer 6 reset
    5 => tim7rst,  //= Timer 7 reset
    6 => tim12rst,  //= Timer 12 reset
    7 => tim13rst,  //= Timer 13 reset
    8 => tim14rst,  //= Timer 14 reset
    11 => wwdgrst,  //= Window watchdog reset
    14 => spi2rst,  //= SPI2 reset
    15 => spi3rst,  //= SPI3 reset
    17 => usart2rst,  //= USART 2 reset
    18 => usart3rst,  //= USART 3 reset
    19 => uart4rst,  //= UART 4 reset
    20 => uart5rst,  //= UART 5 reset
    21 => i2c1rst,  //= I2C1 reset
    22 => i2c2rst,  //= I2C2 reset
    23 => usbrst,  //= USB reset
    25 => canrst,  //= CAN reset
    27 => bkprst,  //= Backup interface reset
    28 => pwrrst,  //= Power interface reset
    29 => dacrst,  //= DAC interface reset
  },
  0x14 => reg32 ahbenr {  //! AHB Peripheral Clock enable register           (RCC_AHBENR)
    0 => dma1en,  //= DMA1 clock enable
    1 => dma2en,  //= DMA2 clock enable
    2 => sramen,  //= SRAM interface clock               enable
    4 => flitfen,  //= FLITF clock enable
    6 => crcen,  //= CRC clock enable
    8 => fsmcen,  //= FSMC clock enable
    10 => sdioen,  //= SDIO clock enable
  },
  0x18 => reg32 apb2enr {  //! APB2 peripheral clock enable register           (RCC_APB2ENR)
    0 => afioen,  //= Alternate function I/O clock               enable
    2 => iopaen,  //= I/O port A clock enable
    3 => iopben,  //= I/O port B clock enable
    4 => iopcen,  //= I/O port C clock enable
    5 => iopden,  //= I/O port D clock enable
    6 => iopeen,  //= I/O port E clock enable
    7 => iopfen,  //= I/O port F clock enable
    8 => iopgen,  //= I/O port G clock enable
    9 => adc1en,  //= ADC 1 interface clock               enable
    10 => adc2en,  //= ADC 2 interface clock               enable
    11 => tim1en,  //= TIM1 Timer clock enable
    12 => spi1en,  //= SPI 1 clock enable
    13 => tim8en,  //= TIM8 Timer clock enable
    14 => usart1en,  //= USART1 clock enable
    15 => adc3en,  //= ADC3 interface clock               enable
    19 => tim9en,  //= TIM9 Timer clock enable
    20 => tim10en,  //= TIM10 Timer clock enable
    21 => tim11en,  //= TIM11 Timer clock enable
  },
  0x1c => reg32 apb1enr {  //! APB1 peripheral clock enable register           (RCC_APB1ENR)
    0 => tim2en,  //= Timer 2 clock enable
    1 => tim3en,  //= Timer 3 clock enable
    2 => tim4en,  //= Timer 4 clock enable
    3 => tim5en,  //= Timer 5 clock enable
    4 => tim6en,  //= Timer 6 clock enable
    5 => tim7en,  //= Timer 7 clock enable
    6 => tim12en,  //= Timer 12 clock enable
    7 => tim13en,  //= Timer 13 clock enable
    8 => tim14en,  //= Timer 14 clock enable
    11 => wwdgen,  //= Window watchdog clock               enable
    14 => spi2en,  //= SPI 2 clock enable
    15 => spi3en,  //= SPI 3 clock enable
    17 => usart2en,  //= USART 2 clock enable
    18 => usart3en,  //= USART 3 clock enable
    19 => uart4en,  //= UART 4 clock enable
    20 => uart5en,  //= UART 5 clock enable
    21 => i2c1en,  //= I2C 1 clock enable
    22 => i2c2en,  //= I2C 2 clock enable
    23 => usben,  //= USB clock enable
    25 => canen,  //= CAN clock enable
    27 => bkpen,  //= Backup interface clock               enable
    28 => pwren,  //= Power interface clock               enable
    29 => dacen,  //= DAC interface clock enable
  },
  0x20 => reg32 bdcr {  //! Backup domain control register           (RCC_BDCR)
    0 => lseon,  //= External Low Speed oscillator               enable
    1 => lserdy: ro,  //= External Low Speed oscillator               ready
    2 => lsebyp,  //= External Low Speed oscillator               bypass
    9..8 => rtcsel,  //= RTC clock source selection
    15 => rtcen,  //= RTC clock enable
    16 => bdrst,  //= Backup domain software               reset
  },
  0x24 => reg32 csr {  //! Control/status register           (RCC_CSR)
    0 => lsion,  //= Internal low speed oscillator               enable
    1 => lsirdy: ro,  //= Internal low speed oscillator               ready
    24 => rmvf,  //= Remove reset flag
    26 => pinrstf,  //= PIN reset flag
    27 => porrstf,  //= POR/PDR reset flag
    28 => sftrstf,  //= Software reset flag
    29 => iwdgrstf,  //= Independent watchdog reset               flag
    30 => wwdgrstf,  //= Window watchdog reset flag
    31 => lpwrrstf,  //= Low-power reset flag
  },
});
ioregs! (GPIOA @ 0x40010800 = {  //! General purpose I/O
  0x00 => reg32 crl {  //! Port configuration register low           (GPIOn_CRL)
    1..0 => mode0,  //= Port n.0 mode bits
    3..2 => cnf0,  //= Port n.0 configuration               bits
    5..4 => mode1,  //= Port n.1 mode bits
    7..6 => cnf1,  //= Port n.1 configuration               bits
    9..8 => mode2,  //= Port n.2 mode bits
    11..10 => cnf2,  //= Port n.2 configuration               bits
    13..12 => mode3,  //= Port n.3 mode bits
    15..14 => cnf3,  //= Port n.3 configuration               bits
    17..16 => mode4,  //= Port n.4 mode bits
    19..18 => cnf4,  //= Port n.4 configuration               bits
    21..20 => mode5,  //= Port n.5 mode bits
    23..22 => cnf5,  //= Port n.5 configuration               bits
    25..24 => mode6,  //= Port n.6 mode bits
    27..26 => cnf6,  //= Port n.6 configuration               bits
    29..28 => mode7,  //= Port n.7 mode bits
    31..30 => cnf7,  //= Port n.7 configuration               bits
  },
  0x04 => reg32 crh {  //! Port configuration register high           (GPIOn_CRL)
    1..0 => mode8,  //= Port n.8 mode bits
    3..2 => cnf8,  //= Port n.8 configuration               bits
    5..4 => mode9,  //= Port n.9 mode bits
    7..6 => cnf9,  //= Port n.9 configuration               bits
    9..8 => mode10,  //= Port n.10 mode bits
    11..10 => cnf10,  //= Port n.10 configuration               bits
    13..12 => mode11,  //= Port n.11 mode bits
    15..14 => cnf11,  //= Port n.11 configuration               bits
    17..16 => mode12,  //= Port n.12 mode bits
    19..18 => cnf12,  //= Port n.12 configuration               bits
    21..20 => mode13,  //= Port n.13 mode bits
    23..22 => cnf13,  //= Port n.13 configuration               bits
    25..24 => mode14,  //= Port n.14 mode bits
    27..26 => cnf14,  //= Port n.14 configuration               bits
    29..28 => mode15,  //= Port n.15 mode bits
    31..30 => cnf15,  //= Port n.15 configuration               bits
  },
  0x08 => reg32 idr {  //! Port input data register           (GPIOn_IDR)
    0 => idr0: ro,  //= Port input data
    1 => idr1: ro,  //= Port input data
    2 => idr2: ro,  //= Port input data
    3 => idr3: ro,  //= Port input data
    4 => idr4: ro,  //= Port input data
    5 => idr5: ro,  //= Port input data
    6 => idr6: ro,  //= Port input data
    7 => idr7: ro,  //= Port input data
    8 => idr8: ro,  //= Port input data
    9 => idr9: ro,  //= Port input data
    10 => idr10: ro,  //= Port input data
    11 => idr11: ro,  //= Port input data
    12 => idr12: ro,  //= Port input data
    13 => idr13: ro,  //= Port input data
    14 => idr14: ro,  //= Port input data
    15 => idr15: ro,  //= Port input data
  },
  0x0c => reg32 odr {  //! Port output data register           (GPIOn_ODR)
    0 => odr0,  //= Port output data
    1 => odr1,  //= Port output data
    2 => odr2,  //= Port output data
    3 => odr3,  //= Port output data
    4 => odr4,  //= Port output data
    5 => odr5,  //= Port output data
    6 => odr6,  //= Port output data
    7 => odr7,  //= Port output data
    8 => odr8,  //= Port output data
    9 => odr9,  //= Port output data
    10 => odr10,  //= Port output data
    11 => odr11,  //= Port output data
    12 => odr12,  //= Port output data
    13 => odr13,  //= Port output data
    14 => odr14,  //= Port output data
    15 => odr15,  //= Port output data
  },
  0x10 => reg32 bsrr {  //! Port bit set/reset register           (GPIOn_BSRR)
    0 => bs0: wo,  //= Set bit 0
    1 => bs1: wo,  //= Set bit 1
    2 => bs2: wo,  //= Set bit 1
    3 => bs3: wo,  //= Set bit 3
    4 => bs4: wo,  //= Set bit 4
    5 => bs5: wo,  //= Set bit 5
    6 => bs6: wo,  //= Set bit 6
    7 => bs7: wo,  //= Set bit 7
    8 => bs8: wo,  //= Set bit 8
    9 => bs9: wo,  //= Set bit 9
    10 => bs10: wo,  //= Set bit 10
    11 => bs11: wo,  //= Set bit 11
    12 => bs12: wo,  //= Set bit 12
    13 => bs13: wo,  //= Set bit 13
    14 => bs14: wo,  //= Set bit 14
    15 => bs15: wo,  //= Set bit 15
    16 => br0: wo,  //= Reset bit 0
    17 => br1: wo,  //= Reset bit 1
    18 => br2: wo,  //= Reset bit 2
    19 => br3: wo,  //= Reset bit 3
    20 => br4: wo,  //= Reset bit 4
    21 => br5: wo,  //= Reset bit 5
    22 => br6: wo,  //= Reset bit 6
    23 => br7: wo,  //= Reset bit 7
    24 => br8: wo,  //= Reset bit 8
    25 => br9: wo,  //= Reset bit 9
    26 => br10: wo,  //= Reset bit 10
    27 => br11: wo,  //= Reset bit 11
    28 => br12: wo,  //= Reset bit 12
    29 => br13: wo,  //= Reset bit 13
    30 => br14: wo,  //= Reset bit 14
    31 => br15: wo,  //= Reset bit 15
  },
  0x14 => reg32 brr {  //! Port bit reset register           (GPIOn_BRR)
    0 => br0: wo,  //= Reset bit 0
    1 => br1: wo,  //= Reset bit 1
    2 => br2: wo,  //= Reset bit 1
    3 => br3: wo,  //= Reset bit 3
    4 => br4: wo,  //= Reset bit 4
    5 => br5: wo,  //= Reset bit 5
    6 => br6: wo,  //= Reset bit 6
    7 => br7: wo,  //= Reset bit 7
    8 => br8: wo,  //= Reset bit 8
    9 => br9: wo,  //= Reset bit 9
    10 => br10: wo,  //= Reset bit 10
    11 => br11: wo,  //= Reset bit 11
    12 => br12: wo,  //= Reset bit 12
    13 => br13: wo,  //= Reset bit 13
    14 => br14: wo,  //= Reset bit 14
    15 => br15: wo,  //= Reset bit 15
  },
  0x18 => reg32 lckr {  //! Port configuration lock           register
    0 => lck0,  //= Port A Lock bit 0
    1 => lck1,  //= Port A Lock bit 1
    2 => lck2,  //= Port A Lock bit 2
    3 => lck3,  //= Port A Lock bit 3
    4 => lck4,  //= Port A Lock bit 4
    5 => lck5,  //= Port A Lock bit 5
    6 => lck6,  //= Port A Lock bit 6
    7 => lck7,  //= Port A Lock bit 7
    8 => lck8,  //= Port A Lock bit 8
    9 => lck9,  //= Port A Lock bit 9
    10 => lck10,  //= Port A Lock bit 10
    11 => lck11,  //= Port A Lock bit 11
    12 => lck12,  //= Port A Lock bit 12
    13 => lck13,  //= Port A Lock bit 13
    14 => lck14,  //= Port A Lock bit 14
    15 => lck15,  //= Port A Lock bit 15
    16 => lckk,  //= Lock key
  },
});
ioregs! (GPIOB @ 0x40010c00 = {  //! General purpose I/O
  0x00 => reg32 crl {  //! Port configuration register low           (GPIOn_CRL)
    1..0 => mode0,  //= Port n.0 mode bits
    3..2 => cnf0,  //= Port n.0 configuration               bits
    5..4 => mode1,  //= Port n.1 mode bits
    7..6 => cnf1,  //= Port n.1 configuration               bits
    9..8 => mode2,  //= Port n.2 mode bits
    11..10 => cnf2,  //= Port n.2 configuration               bits
    13..12 => mode3,  //= Port n.3 mode bits
    15..14 => cnf3,  //= Port n.3 configuration               bits
    17..16 => mode4,  //= Port n.4 mode bits
    19..18 => cnf4,  //= Port n.4 configuration               bits
    21..20 => mode5,  //= Port n.5 mode bits
    23..22 => cnf5,  //= Port n.5 configuration               bits
    25..24 => mode6,  //= Port n.6 mode bits
    27..26 => cnf6,  //= Port n.6 configuration               bits
    29..28 => mode7,  //= Port n.7 mode bits
    31..30 => cnf7,  //= Port n.7 configuration               bits
  },
  0x04 => reg32 crh {  //! Port configuration register high           (GPIOn_CRL)
    1..0 => mode8,  //= Port n.8 mode bits
    3..2 => cnf8,  //= Port n.8 configuration               bits
    5..4 => mode9,  //= Port n.9 mode bits
    7..6 => cnf9,  //= Port n.9 configuration               bits
    9..8 => mode10,  //= Port n.10 mode bits
    11..10 => cnf10,  //= Port n.10 configuration               bits
    13..12 => mode11,  //= Port n.11 mode bits
    15..14 => cnf11,  //= Port n.11 configuration               bits
    17..16 => mode12,  //= Port n.12 mode bits
    19..18 => cnf12,  //= Port n.12 configuration               bits
    21..20 => mode13,  //= Port n.13 mode bits
    23..22 => cnf13,  //= Port n.13 configuration               bits
    25..24 => mode14,  //= Port n.14 mode bits
    27..26 => cnf14,  //= Port n.14 configuration               bits
    29..28 => mode15,  //= Port n.15 mode bits
    31..30 => cnf15,  //= Port n.15 configuration               bits
  },
  0x08 => reg32 idr {  //! Port input data register           (GPIOn_IDR)
    0 => idr0: ro,  //= Port input data
    1 => idr1: ro,  //= Port input data
    2 => idr2: ro,  //= Port input data
    3 => idr3: ro,  //= Port input data
    4 => idr4: ro,  //= Port input data
    5 => idr5: ro,  //= Port input data
    6 => idr6: ro,  //= Port input data
    7 => idr7: ro,  //= Port input data
    8 => idr8: ro,  //= Port input data
    9 => idr9: ro,  //= Port input data
    10 => idr10: ro,  //= Port input data
    11 => idr11: ro,  //= Port input data
    12 => idr12: ro,  //= Port input data
    13 => idr13: ro,  //= Port input data
    14 => idr14: ro,  //= Port input data
    15 => idr15: ro,  //= Port input data
  },
  0x0c => reg32 odr {  //! Port output data register           (GPIOn_ODR)
    0 => odr0,  //= Port output data
    1 => odr1,  //= Port output data
    2 => odr2,  //= Port output data
    3 => odr3,  //= Port output data
    4 => odr4,  //= Port output data
    5 => odr5,  //= Port output data
    6 => odr6,  //= Port output data
    7 => odr7,  //= Port output data
    8 => odr8,  //= Port output data
    9 => odr9,  //= Port output data
    10 => odr10,  //= Port output data
    11 => odr11,  //= Port output data
    12 => odr12,  //= Port output data
    13 => odr13,  //= Port output data
    14 => odr14,  //= Port output data
    15 => odr15,  //= Port output data
  },
  0x10 => reg32 bsrr {  //! Port bit set/reset register           (GPIOn_BSRR)
    0 => bs0: wo,  //= Set bit 0
    1 => bs1: wo,  //= Set bit 1
    2 => bs2: wo,  //= Set bit 1
    3 => bs3: wo,  //= Set bit 3
    4 => bs4: wo,  //= Set bit 4
    5 => bs5: wo,  //= Set bit 5
    6 => bs6: wo,  //= Set bit 6
    7 => bs7: wo,  //= Set bit 7
    8 => bs8: wo,  //= Set bit 8
    9 => bs9: wo,  //= Set bit 9
    10 => bs10: wo,  //= Set bit 10
    11 => bs11: wo,  //= Set bit 11
    12 => bs12: wo,  //= Set bit 12
    13 => bs13: wo,  //= Set bit 13
    14 => bs14: wo,  //= Set bit 14
    15 => bs15: wo,  //= Set bit 15
    16 => br0: wo,  //= Reset bit 0
    17 => br1: wo,  //= Reset bit 1
    18 => br2: wo,  //= Reset bit 2
    19 => br3: wo,  //= Reset bit 3
    20 => br4: wo,  //= Reset bit 4
    21 => br5: wo,  //= Reset bit 5
    22 => br6: wo,  //= Reset bit 6
    23 => br7: wo,  //= Reset bit 7
    24 => br8: wo,  //= Reset bit 8
    25 => br9: wo,  //= Reset bit 9
    26 => br10: wo,  //= Reset bit 10
    27 => br11: wo,  //= Reset bit 11
    28 => br12: wo,  //= Reset bit 12
    29 => br13: wo,  //= Reset bit 13
    30 => br14: wo,  //= Reset bit 14
    31 => br15: wo,  //= Reset bit 15
  },
  0x14 => reg32 brr {  //! Port bit reset register           (GPIOn_BRR)
    0 => br0: wo,  //= Reset bit 0
    1 => br1: wo,  //= Reset bit 1
    2 => br2: wo,  //= Reset bit 1
    3 => br3: wo,  //= Reset bit 3
    4 => br4: wo,  //= Reset bit 4
    5 => br5: wo,  //= Reset bit 5
    6 => br6: wo,  //= Reset bit 6
    7 => br7: wo,  //= Reset bit 7
    8 => br8: wo,  //= Reset bit 8
    9 => br9: wo,  //= Reset bit 9
    10 => br10: wo,  //= Reset bit 10
    11 => br11: wo,  //= Reset bit 11
    12 => br12: wo,  //= Reset bit 12
    13 => br13: wo,  //= Reset bit 13
    14 => br14: wo,  //= Reset bit 14
    15 => br15: wo,  //= Reset bit 15
  },
  0x18 => reg32 lckr {  //! Port configuration lock           register
    0 => lck0,  //= Port A Lock bit 0
    1 => lck1,  //= Port A Lock bit 1
    2 => lck2,  //= Port A Lock bit 2
    3 => lck3,  //= Port A Lock bit 3
    4 => lck4,  //= Port A Lock bit 4
    5 => lck5,  //= Port A Lock bit 5
    6 => lck6,  //= Port A Lock bit 6
    7 => lck7,  //= Port A Lock bit 7
    8 => lck8,  //= Port A Lock bit 8
    9 => lck9,  //= Port A Lock bit 9
    10 => lck10,  //= Port A Lock bit 10
    11 => lck11,  //= Port A Lock bit 11
    12 => lck12,  //= Port A Lock bit 12
    13 => lck13,  //= Port A Lock bit 13
    14 => lck14,  //= Port A Lock bit 14
    15 => lck15,  //= Port A Lock bit 15
    16 => lckk,  //= Lock key
  },
});
ioregs! (GPIOC @ 0x40011000 = {  //! General purpose I/O
  0x00 => reg32 crl {  //! Port configuration register low           (GPIOn_CRL)
    1..0 => mode0,  //= Port n.0 mode bits
    3..2 => cnf0,  //= Port n.0 configuration               bits
    5..4 => mode1,  //= Port n.1 mode bits
    7..6 => cnf1,  //= Port n.1 configuration               bits
    9..8 => mode2,  //= Port n.2 mode bits
    11..10 => cnf2,  //= Port n.2 configuration               bits
    13..12 => mode3,  //= Port n.3 mode bits
    15..14 => cnf3,  //= Port n.3 configuration               bits
    17..16 => mode4,  //= Port n.4 mode bits
    19..18 => cnf4,  //= Port n.4 configuration               bits
    21..20 => mode5,  //= Port n.5 mode bits
    23..22 => cnf5,  //= Port n.5 configuration               bits
    25..24 => mode6,  //= Port n.6 mode bits
    27..26 => cnf6,  //= Port n.6 configuration               bits
    29..28 => mode7,  //= Port n.7 mode bits
    31..30 => cnf7,  //= Port n.7 configuration               bits
  },
  0x04 => reg32 crh {  //! Port configuration register high           (GPIOn_CRL)
    1..0 => mode8,  //= Port n.8 mode bits
    3..2 => cnf8,  //= Port n.8 configuration               bits
    5..4 => mode9,  //= Port n.9 mode bits
    7..6 => cnf9,  //= Port n.9 configuration               bits
    9..8 => mode10,  //= Port n.10 mode bits
    11..10 => cnf10,  //= Port n.10 configuration               bits
    13..12 => mode11,  //= Port n.11 mode bits
    15..14 => cnf11,  //= Port n.11 configuration               bits
    17..16 => mode12,  //= Port n.12 mode bits
    19..18 => cnf12,  //= Port n.12 configuration               bits
    21..20 => mode13,  //= Port n.13 mode bits
    23..22 => cnf13,  //= Port n.13 configuration               bits
    25..24 => mode14,  //= Port n.14 mode bits
    27..26 => cnf14,  //= Port n.14 configuration               bits
    29..28 => mode15,  //= Port n.15 mode bits
    31..30 => cnf15,  //= Port n.15 configuration               bits
  },
  0x08 => reg32 idr {  //! Port input data register           (GPIOn_IDR)
    0 => idr0: ro,  //= Port input data
    1 => idr1: ro,  //= Port input data
    2 => idr2: ro,  //= Port input data
    3 => idr3: ro,  //= Port input data
    4 => idr4: ro,  //= Port input data
    5 => idr5: ro,  //= Port input data
    6 => idr6: ro,  //= Port input data
    7 => idr7: ro,  //= Port input data
    8 => idr8: ro,  //= Port input data
    9 => idr9: ro,  //= Port input data
    10 => idr10: ro,  //= Port input data
    11 => idr11: ro,  //= Port input data
    12 => idr12: ro,  //= Port input data
    13 => idr13: ro,  //= Port input data
    14 => idr14: ro,  //= Port input data
    15 => idr15: ro,  //= Port input data
  },
  0x0c => reg32 odr {  //! Port output data register           (GPIOn_ODR)
    0 => odr0,  //= Port output data
    1 => odr1,  //= Port output data
    2 => odr2,  //= Port output data
    3 => odr3,  //= Port output data
    4 => odr4,  //= Port output data
    5 => odr5,  //= Port output data
    6 => odr6,  //= Port output data
    7 => odr7,  //= Port output data
    8 => odr8,  //= Port output data
    9 => odr9,  //= Port output data
    10 => odr10,  //= Port output data
    11 => odr11,  //= Port output data
    12 => odr12,  //= Port output data
    13 => odr13,  //= Port output data
    14 => odr14,  //= Port output data
    15 => odr15,  //= Port output data
  },
  0x10 => reg32 bsrr {  //! Port bit set/reset register           (GPIOn_BSRR)
    0 => bs0: wo,  //= Set bit 0
    1 => bs1: wo,  //= Set bit 1
    2 => bs2: wo,  //= Set bit 1
    3 => bs3: wo,  //= Set bit 3
    4 => bs4: wo,  //= Set bit 4
    5 => bs5: wo,  //= Set bit 5
    6 => bs6: wo,  //= Set bit 6
    7 => bs7: wo,  //= Set bit 7
    8 => bs8: wo,  //= Set bit 8
    9 => bs9: wo,  //= Set bit 9
    10 => bs10: wo,  //= Set bit 10
    11 => bs11: wo,  //= Set bit 11
    12 => bs12: wo,  //= Set bit 12
    13 => bs13: wo,  //= Set bit 13
    14 => bs14: wo,  //= Set bit 14
    15 => bs15: wo,  //= Set bit 15
    16 => br0: wo,  //= Reset bit 0
    17 => br1: wo,  //= Reset bit 1
    18 => br2: wo,  //= Reset bit 2
    19 => br3: wo,  //= Reset bit 3
    20 => br4: wo,  //= Reset bit 4
    21 => br5: wo,  //= Reset bit 5
    22 => br6: wo,  //= Reset bit 6
    23 => br7: wo,  //= Reset bit 7
    24 => br8: wo,  //= Reset bit 8
    25 => br9: wo,  //= Reset bit 9
    26 => br10: wo,  //= Reset bit 10
    27 => br11: wo,  //= Reset bit 11
    28 => br12: wo,  //= Reset bit 12
    29 => br13: wo,  //= Reset bit 13
    30 => br14: wo,  //= Reset bit 14
    31 => br15: wo,  //= Reset bit 15
  },
  0x14 => reg32 brr {  //! Port bit reset register           (GPIOn_BRR)
    0 => br0: wo,  //= Reset bit 0
    1 => br1: wo,  //= Reset bit 1
    2 => br2: wo,  //= Reset bit 1
    3 => br3: wo,  //= Reset bit 3
    4 => br4: wo,  //= Reset bit 4
    5 => br5: wo,  //= Reset bit 5
    6 => br6: wo,  //= Reset bit 6
    7 => br7: wo,  //= Reset bit 7
    8 => br8: wo,  //= Reset bit 8
    9 => br9: wo,  //= Reset bit 9
    10 => br10: wo,  //= Reset bit 10
    11 => br11: wo,  //= Reset bit 11
    12 => br12: wo,  //= Reset bit 12
    13 => br13: wo,  //= Reset bit 13
    14 => br14: wo,  //= Reset bit 14
    15 => br15: wo,  //= Reset bit 15
  },
  0x18 => reg32 lckr {  //! Port configuration lock           register
    0 => lck0,  //= Port A Lock bit 0
    1 => lck1,  //= Port A Lock bit 1
    2 => lck2,  //= Port A Lock bit 2
    3 => lck3,  //= Port A Lock bit 3
    4 => lck4,  //= Port A Lock bit 4
    5 => lck5,  //= Port A Lock bit 5
    6 => lck6,  //= Port A Lock bit 6
    7 => lck7,  //= Port A Lock bit 7
    8 => lck8,  //= Port A Lock bit 8
    9 => lck9,  //= Port A Lock bit 9
    10 => lck10,  //= Port A Lock bit 10
    11 => lck11,  //= Port A Lock bit 11
    12 => lck12,  //= Port A Lock bit 12
    13 => lck13,  //= Port A Lock bit 13
    14 => lck14,  //= Port A Lock bit 14
    15 => lck15,  //= Port A Lock bit 15
    16 => lckk,  //= Lock key
  },
});
ioregs! (GPIOD @ 0x40011400 = {  //! General purpose I/O
  0x00 => reg32 crl {  //! Port configuration register low           (GPIOn_CRL)
    1..0 => mode0,  //= Port n.0 mode bits
    3..2 => cnf0,  //= Port n.0 configuration               bits
    5..4 => mode1,  //= Port n.1 mode bits
    7..6 => cnf1,  //= Port n.1 configuration               bits
    9..8 => mode2,  //= Port n.2 mode bits
    11..10 => cnf2,  //= Port n.2 configuration               bits
    13..12 => mode3,  //= Port n.3 mode bits
    15..14 => cnf3,  //= Port n.3 configuration               bits
    17..16 => mode4,  //= Port n.4 mode bits
    19..18 => cnf4,  //= Port n.4 configuration               bits
    21..20 => mode5,  //= Port n.5 mode bits
    23..22 => cnf5,  //= Port n.5 configuration               bits
    25..24 => mode6,  //= Port n.6 mode bits
    27..26 => cnf6,  //= Port n.6 configuration               bits
    29..28 => mode7,  //= Port n.7 mode bits
    31..30 => cnf7,  //= Port n.7 configuration               bits
  },
  0x04 => reg32 crh {  //! Port configuration register high           (GPIOn_CRL)
    1..0 => mode8,  //= Port n.8 mode bits
    3..2 => cnf8,  //= Port n.8 configuration               bits
    5..4 => mode9,  //= Port n.9 mode bits
    7..6 => cnf9,  //= Port n.9 configuration               bits
    9..8 => mode10,  //= Port n.10 mode bits
    11..10 => cnf10,  //= Port n.10 configuration               bits
    13..12 => mode11,  //= Port n.11 mode bits
    15..14 => cnf11,  //= Port n.11 configuration               bits
    17..16 => mode12,  //= Port n.12 mode bits
    19..18 => cnf12,  //= Port n.12 configuration               bits
    21..20 => mode13,  //= Port n.13 mode bits
    23..22 => cnf13,  //= Port n.13 configuration               bits
    25..24 => mode14,  //= Port n.14 mode bits
    27..26 => cnf14,  //= Port n.14 configuration               bits
    29..28 => mode15,  //= Port n.15 mode bits
    31..30 => cnf15,  //= Port n.15 configuration               bits
  },
  0x08 => reg32 idr {  //! Port input data register           (GPIOn_IDR)
    0 => idr0: ro,  //= Port input data
    1 => idr1: ro,  //= Port input data
    2 => idr2: ro,  //= Port input data
    3 => idr3: ro,  //= Port input data
    4 => idr4: ro,  //= Port input data
    5 => idr5: ro,  //= Port input data
    6 => idr6: ro,  //= Port input data
    7 => idr7: ro,  //= Port input data
    8 => idr8: ro,  //= Port input data
    9 => idr9: ro,  //= Port input data
    10 => idr10: ro,  //= Port input data
    11 => idr11: ro,  //= Port input data
    12 => idr12: ro,  //= Port input data
    13 => idr13: ro,  //= Port input data
    14 => idr14: ro,  //= Port input data
    15 => idr15: ro,  //= Port input data
  },
  0x0c => reg32 odr {  //! Port output data register           (GPIOn_ODR)
    0 => odr0,  //= Port output data
    1 => odr1,  //= Port output data
    2 => odr2,  //= Port output data
    3 => odr3,  //= Port output data
    4 => odr4,  //= Port output data
    5 => odr5,  //= Port output data
    6 => odr6,  //= Port output data
    7 => odr7,  //= Port output data
    8 => odr8,  //= Port output data
    9 => odr9,  //= Port output data
    10 => odr10,  //= Port output data
    11 => odr11,  //= Port output data
    12 => odr12,  //= Port output data
    13 => odr13,  //= Port output data
    14 => odr14,  //= Port output data
    15 => odr15,  //= Port output data
  },
  0x10 => reg32 bsrr {  //! Port bit set/reset register           (GPIOn_BSRR)
    0 => bs0: wo,  //= Set bit 0
    1 => bs1: wo,  //= Set bit 1
    2 => bs2: wo,  //= Set bit 1
    3 => bs3: wo,  //= Set bit 3
    4 => bs4: wo,  //= Set bit 4
    5 => bs5: wo,  //= Set bit 5
    6 => bs6: wo,  //= Set bit 6
    7 => bs7: wo,  //= Set bit 7
    8 => bs8: wo,  //= Set bit 8
    9 => bs9: wo,  //= Set bit 9
    10 => bs10: wo,  //= Set bit 10
    11 => bs11: wo,  //= Set bit 11
    12 => bs12: wo,  //= Set bit 12
    13 => bs13: wo,  //= Set bit 13
    14 => bs14: wo,  //= Set bit 14
    15 => bs15: wo,  //= Set bit 15
    16 => br0: wo,  //= Reset bit 0
    17 => br1: wo,  //= Reset bit 1
    18 => br2: wo,  //= Reset bit 2
    19 => br3: wo,  //= Reset bit 3
    20 => br4: wo,  //= Reset bit 4
    21 => br5: wo,  //= Reset bit 5
    22 => br6: wo,  //= Reset bit 6
    23 => br7: wo,  //= Reset bit 7
    24 => br8: wo,  //= Reset bit 8
    25 => br9: wo,  //= Reset bit 9
    26 => br10: wo,  //= Reset bit 10
    27 => br11: wo,  //= Reset bit 11
    28 => br12: wo,  //= Reset bit 12
    29 => br13: wo,  //= Reset bit 13
    30 => br14: wo,  //= Reset bit 14
    31 => br15: wo,  //= Reset bit 15
  },
  0x14 => reg32 brr {  //! Port bit reset register           (GPIOn_BRR)
    0 => br0: wo,  //= Reset bit 0
    1 => br1: wo,  //= Reset bit 1
    2 => br2: wo,  //= Reset bit 1
    3 => br3: wo,  //= Reset bit 3
    4 => br4: wo,  //= Reset bit 4
    5 => br5: wo,  //= Reset bit 5
    6 => br6: wo,  //= Reset bit 6
    7 => br7: wo,  //= Reset bit 7
    8 => br8: wo,  //= Reset bit 8
    9 => br9: wo,  //= Reset bit 9
    10 => br10: wo,  //= Reset bit 10
    11 => br11: wo,  //= Reset bit 11
    12 => br12: wo,  //= Reset bit 12
    13 => br13: wo,  //= Reset bit 13
    14 => br14: wo,  //= Reset bit 14
    15 => br15: wo,  //= Reset bit 15
  },
  0x18 => reg32 lckr {  //! Port configuration lock           register
    0 => lck0,  //= Port A Lock bit 0
    1 => lck1,  //= Port A Lock bit 1
    2 => lck2,  //= Port A Lock bit 2
    3 => lck3,  //= Port A Lock bit 3
    4 => lck4,  //= Port A Lock bit 4
    5 => lck5,  //= Port A Lock bit 5
    6 => lck6,  //= Port A Lock bit 6
    7 => lck7,  //= Port A Lock bit 7
    8 => lck8,  //= Port A Lock bit 8
    9 => lck9,  //= Port A Lock bit 9
    10 => lck10,  //= Port A Lock bit 10
    11 => lck11,  //= Port A Lock bit 11
    12 => lck12,  //= Port A Lock bit 12
    13 => lck13,  //= Port A Lock bit 13
    14 => lck14,  //= Port A Lock bit 14
    15 => lck15,  //= Port A Lock bit 15
    16 => lckk,  //= Lock key
  },
});
ioregs! (GPIOE @ 0x40011800 = {  //! General purpose I/O
  0x00 => reg32 crl {  //! Port configuration register low           (GPIOn_CRL)
    1..0 => mode0,  //= Port n.0 mode bits
    3..2 => cnf0,  //= Port n.0 configuration               bits
    5..4 => mode1,  //= Port n.1 mode bits
    7..6 => cnf1,  //= Port n.1 configuration               bits
    9..8 => mode2,  //= Port n.2 mode bits
    11..10 => cnf2,  //= Port n.2 configuration               bits
    13..12 => mode3,  //= Port n.3 mode bits
    15..14 => cnf3,  //= Port n.3 configuration               bits
    17..16 => mode4,  //= Port n.4 mode bits
    19..18 => cnf4,  //= Port n.4 configuration               bits
    21..20 => mode5,  //= Port n.5 mode bits
    23..22 => cnf5,  //= Port n.5 configuration               bits
    25..24 => mode6,  //= Port n.6 mode bits
    27..26 => cnf6,  //= Port n.6 configuration               bits
    29..28 => mode7,  //= Port n.7 mode bits
    31..30 => cnf7,  //= Port n.7 configuration               bits
  },
  0x04 => reg32 crh {  //! Port configuration register high           (GPIOn_CRL)
    1..0 => mode8,  //= Port n.8 mode bits
    3..2 => cnf8,  //= Port n.8 configuration               bits
    5..4 => mode9,  //= Port n.9 mode bits
    7..6 => cnf9,  //= Port n.9 configuration               bits
    9..8 => mode10,  //= Port n.10 mode bits
    11..10 => cnf10,  //= Port n.10 configuration               bits
    13..12 => mode11,  //= Port n.11 mode bits
    15..14 => cnf11,  //= Port n.11 configuration               bits
    17..16 => mode12,  //= Port n.12 mode bits
    19..18 => cnf12,  //= Port n.12 configuration               bits
    21..20 => mode13,  //= Port n.13 mode bits
    23..22 => cnf13,  //= Port n.13 configuration               bits
    25..24 => mode14,  //= Port n.14 mode bits
    27..26 => cnf14,  //= Port n.14 configuration               bits
    29..28 => mode15,  //= Port n.15 mode bits
    31..30 => cnf15,  //= Port n.15 configuration               bits
  },
  0x08 => reg32 idr {  //! Port input data register           (GPIOn_IDR)
    0 => idr0: ro,  //= Port input data
    1 => idr1: ro,  //= Port input data
    2 => idr2: ro,  //= Port input data
    3 => idr3: ro,  //= Port input data
    4 => idr4: ro,  //= Port input data
    5 => idr5: ro,  //= Port input data
    6 => idr6: ro,  //= Port input data
    7 => idr7: ro,  //= Port input data
    8 => idr8: ro,  //= Port input data
    9 => idr9: ro,  //= Port input data
    10 => idr10: ro,  //= Port input data
    11 => idr11: ro,  //= Port input data
    12 => idr12: ro,  //= Port input data
    13 => idr13: ro,  //= Port input data
    14 => idr14: ro,  //= Port input data
    15 => idr15: ro,  //= Port input data
  },
  0x0c => reg32 odr {  //! Port output data register           (GPIOn_ODR)
    0 => odr0,  //= Port output data
    1 => odr1,  //= Port output data
    2 => odr2,  //= Port output data
    3 => odr3,  //= Port output data
    4 => odr4,  //= Port output data
    5 => odr5,  //= Port output data
    6 => odr6,  //= Port output data
    7 => odr7,  //= Port output data
    8 => odr8,  //= Port output data
    9 => odr9,  //= Port output data
    10 => odr10,  //= Port output data
    11 => odr11,  //= Port output data
    12 => odr12,  //= Port output data
    13 => odr13,  //= Port output data
    14 => odr14,  //= Port output data
    15 => odr15,  //= Port output data
  },
  0x10 => reg32 bsrr {  //! Port bit set/reset register           (GPIOn_BSRR)
    0 => bs0: wo,  //= Set bit 0
    1 => bs1: wo,  //= Set bit 1
    2 => bs2: wo,  //= Set bit 1
    3 => bs3: wo,  //= Set bit 3
    4 => bs4: wo,  //= Set bit 4
    5 => bs5: wo,  //= Set bit 5
    6 => bs6: wo,  //= Set bit 6
    7 => bs7: wo,  //= Set bit 7
    8 => bs8: wo,  //= Set bit 8
    9 => bs9: wo,  //= Set bit 9
    10 => bs10: wo,  //= Set bit 10
    11 => bs11: wo,  //= Set bit 11
    12 => bs12: wo,  //= Set bit 12
    13 => bs13: wo,  //= Set bit 13
    14 => bs14: wo,  //= Set bit 14
    15 => bs15: wo,  //= Set bit 15
    16 => br0: wo,  //= Reset bit 0
    17 => br1: wo,  //= Reset bit 1
    18 => br2: wo,  //= Reset bit 2
    19 => br3: wo,  //= Reset bit 3
    20 => br4: wo,  //= Reset bit 4
    21 => br5: wo,  //= Reset bit 5
    22 => br6: wo,  //= Reset bit 6
    23 => br7: wo,  //= Reset bit 7
    24 => br8: wo,  //= Reset bit 8
    25 => br9: wo,  //= Reset bit 9
    26 => br10: wo,  //= Reset bit 10
    27 => br11: wo,  //= Reset bit 11
    28 => br12: wo,  //= Reset bit 12
    29 => br13: wo,  //= Reset bit 13
    30 => br14: wo,  //= Reset bit 14
    31 => br15: wo,  //= Reset bit 15
  },
  0x14 => reg32 brr {  //! Port bit reset register           (GPIOn_BRR)
    0 => br0: wo,  //= Reset bit 0
    1 => br1: wo,  //= Reset bit 1
    2 => br2: wo,  //= Reset bit 1
    3 => br3: wo,  //= Reset bit 3
    4 => br4: wo,  //= Reset bit 4
    5 => br5: wo,  //= Reset bit 5
    6 => br6: wo,  //= Reset bit 6
    7 => br7: wo,  //= Reset bit 7
    8 => br8: wo,  //= Reset bit 8
    9 => br9: wo,  //= Reset bit 9
    10 => br10: wo,  //= Reset bit 10
    11 => br11: wo,  //= Reset bit 11
    12 => br12: wo,  //= Reset bit 12
    13 => br13: wo,  //= Reset bit 13
    14 => br14: wo,  //= Reset bit 14
    15 => br15: wo,  //= Reset bit 15
  },
  0x18 => reg32 lckr {  //! Port configuration lock           register
    0 => lck0,  //= Port A Lock bit 0
    1 => lck1,  //= Port A Lock bit 1
    2 => lck2,  //= Port A Lock bit 2
    3 => lck3,  //= Port A Lock bit 3
    4 => lck4,  //= Port A Lock bit 4
    5 => lck5,  //= Port A Lock bit 5
    6 => lck6,  //= Port A Lock bit 6
    7 => lck7,  //= Port A Lock bit 7
    8 => lck8,  //= Port A Lock bit 8
    9 => lck9,  //= Port A Lock bit 9
    10 => lck10,  //= Port A Lock bit 10
    11 => lck11,  //= Port A Lock bit 11
    12 => lck12,  //= Port A Lock bit 12
    13 => lck13,  //= Port A Lock bit 13
    14 => lck14,  //= Port A Lock bit 14
    15 => lck15,  //= Port A Lock bit 15
    16 => lckk,  //= Lock key
  },
});
ioregs! (GPIOF @ 0x40011c00 = {  //! General purpose I/O
  0x00 => reg32 crl {  //! Port configuration register low           (GPIOn_CRL)
    1..0 => mode0,  //= Port n.0 mode bits
    3..2 => cnf0,  //= Port n.0 configuration               bits
    5..4 => mode1,  //= Port n.1 mode bits
    7..6 => cnf1,  //= Port n.1 configuration               bits
    9..8 => mode2,  //= Port n.2 mode bits
    11..10 => cnf2,  //= Port n.2 configuration               bits
    13..12 => mode3,  //= Port n.3 mode bits
    15..14 => cnf3,  //= Port n.3 configuration               bits
    17..16 => mode4,  //= Port n.4 mode bits
    19..18 => cnf4,  //= Port n.4 configuration               bits
    21..20 => mode5,  //= Port n.5 mode bits
    23..22 => cnf5,  //= Port n.5 configuration               bits
    25..24 => mode6,  //= Port n.6 mode bits
    27..26 => cnf6,  //= Port n.6 configuration               bits
    29..28 => mode7,  //= Port n.7 mode bits
    31..30 => cnf7,  //= Port n.7 configuration               bits
  },
  0x04 => reg32 crh {  //! Port configuration register high           (GPIOn_CRL)
    1..0 => mode8,  //= Port n.8 mode bits
    3..2 => cnf8,  //= Port n.8 configuration               bits
    5..4 => mode9,  //= Port n.9 mode bits
    7..6 => cnf9,  //= Port n.9 configuration               bits
    9..8 => mode10,  //= Port n.10 mode bits
    11..10 => cnf10,  //= Port n.10 configuration               bits
    13..12 => mode11,  //= Port n.11 mode bits
    15..14 => cnf11,  //= Port n.11 configuration               bits
    17..16 => mode12,  //= Port n.12 mode bits
    19..18 => cnf12,  //= Port n.12 configuration               bits
    21..20 => mode13,  //= Port n.13 mode bits
    23..22 => cnf13,  //= Port n.13 configuration               bits
    25..24 => mode14,  //= Port n.14 mode bits
    27..26 => cnf14,  //= Port n.14 configuration               bits
    29..28 => mode15,  //= Port n.15 mode bits
    31..30 => cnf15,  //= Port n.15 configuration               bits
  },
  0x08 => reg32 idr {  //! Port input data register           (GPIOn_IDR)
    0 => idr0: ro,  //= Port input data
    1 => idr1: ro,  //= Port input data
    2 => idr2: ro,  //= Port input data
    3 => idr3: ro,  //= Port input data
    4 => idr4: ro,  //= Port input data
    5 => idr5: ro,  //= Port input data
    6 => idr6: ro,  //= Port input data
    7 => idr7: ro,  //= Port input data
    8 => idr8: ro,  //= Port input data
    9 => idr9: ro,  //= Port input data
    10 => idr10: ro,  //= Port input data
    11 => idr11: ro,  //= Port input data
    12 => idr12: ro,  //= Port input data
    13 => idr13: ro,  //= Port input data
    14 => idr14: ro,  //= Port input data
    15 => idr15: ro,  //= Port input data
  },
  0x0c => reg32 odr {  //! Port output data register           (GPIOn_ODR)
    0 => odr0,  //= Port output data
    1 => odr1,  //= Port output data
    2 => odr2,  //= Port output data
    3 => odr3,  //= Port output data
    4 => odr4,  //= Port output data
    5 => odr5,  //= Port output data
    6 => odr6,  //= Port output data
    7 => odr7,  //= Port output data
    8 => odr8,  //= Port output data
    9 => odr9,  //= Port output data
    10 => odr10,  //= Port output data
    11 => odr11,  //= Port output data
    12 => odr12,  //= Port output data
    13 => odr13,  //= Port output data
    14 => odr14,  //= Port output data
    15 => odr15,  //= Port output data
  },
  0x10 => reg32 bsrr {  //! Port bit set/reset register           (GPIOn_BSRR)
    0 => bs0: wo,  //= Set bit 0
    1 => bs1: wo,  //= Set bit 1
    2 => bs2: wo,  //= Set bit 1
    3 => bs3: wo,  //= Set bit 3
    4 => bs4: wo,  //= Set bit 4
    5 => bs5: wo,  //= Set bit 5
    6 => bs6: wo,  //= Set bit 6
    7 => bs7: wo,  //= Set bit 7
    8 => bs8: wo,  //= Set bit 8
    9 => bs9: wo,  //= Set bit 9
    10 => bs10: wo,  //= Set bit 10
    11 => bs11: wo,  //= Set bit 11
    12 => bs12: wo,  //= Set bit 12
    13 => bs13: wo,  //= Set bit 13
    14 => bs14: wo,  //= Set bit 14
    15 => bs15: wo,  //= Set bit 15
    16 => br0: wo,  //= Reset bit 0
    17 => br1: wo,  //= Reset bit 1
    18 => br2: wo,  //= Reset bit 2
    19 => br3: wo,  //= Reset bit 3
    20 => br4: wo,  //= Reset bit 4
    21 => br5: wo,  //= Reset bit 5
    22 => br6: wo,  //= Reset bit 6
    23 => br7: wo,  //= Reset bit 7
    24 => br8: wo,  //= Reset bit 8
    25 => br9: wo,  //= Reset bit 9
    26 => br10: wo,  //= Reset bit 10
    27 => br11: wo,  //= Reset bit 11
    28 => br12: wo,  //= Reset bit 12
    29 => br13: wo,  //= Reset bit 13
    30 => br14: wo,  //= Reset bit 14
    31 => br15: wo,  //= Reset bit 15
  },
  0x14 => reg32 brr {  //! Port bit reset register           (GPIOn_BRR)
    0 => br0: wo,  //= Reset bit 0
    1 => br1: wo,  //= Reset bit 1
    2 => br2: wo,  //= Reset bit 1
    3 => br3: wo,  //= Reset bit 3
    4 => br4: wo,  //= Reset bit 4
    5 => br5: wo,  //= Reset bit 5
    6 => br6: wo,  //= Reset bit 6
    7 => br7: wo,  //= Reset bit 7
    8 => br8: wo,  //= Reset bit 8
    9 => br9: wo,  //= Reset bit 9
    10 => br10: wo,  //= Reset bit 10
    11 => br11: wo,  //= Reset bit 11
    12 => br12: wo,  //= Reset bit 12
    13 => br13: wo,  //= Reset bit 13
    14 => br14: wo,  //= Reset bit 14
    15 => br15: wo,  //= Reset bit 15
  },
  0x18 => reg32 lckr {  //! Port configuration lock           register
    0 => lck0,  //= Port A Lock bit 0
    1 => lck1,  //= Port A Lock bit 1
    2 => lck2,  //= Port A Lock bit 2
    3 => lck3,  //= Port A Lock bit 3
    4 => lck4,  //= Port A Lock bit 4
    5 => lck5,  //= Port A Lock bit 5
    6 => lck6,  //= Port A Lock bit 6
    7 => lck7,  //= Port A Lock bit 7
    8 => lck8,  //= Port A Lock bit 8
    9 => lck9,  //= Port A Lock bit 9
    10 => lck10,  //= Port A Lock bit 10
    11 => lck11,  //= Port A Lock bit 11
    12 => lck12,  //= Port A Lock bit 12
    13 => lck13,  //= Port A Lock bit 13
    14 => lck14,  //= Port A Lock bit 14
    15 => lck15,  //= Port A Lock bit 15
    16 => lckk,  //= Lock key
  },
});
ioregs! (GPIOG @ 0x40012000 = {  //! General purpose I/O
  0x00 => reg32 crl {  //! Port configuration register low           (GPIOn_CRL)
    1..0 => mode0,  //= Port n.0 mode bits
    3..2 => cnf0,  //= Port n.0 configuration               bits
    5..4 => mode1,  //= Port n.1 mode bits
    7..6 => cnf1,  //= Port n.1 configuration               bits
    9..8 => mode2,  //= Port n.2 mode bits
    11..10 => cnf2,  //= Port n.2 configuration               bits
    13..12 => mode3,  //= Port n.3 mode bits
    15..14 => cnf3,  //= Port n.3 configuration               bits
    17..16 => mode4,  //= Port n.4 mode bits
    19..18 => cnf4,  //= Port n.4 configuration               bits
    21..20 => mode5,  //= Port n.5 mode bits
    23..22 => cnf5,  //= Port n.5 configuration               bits
    25..24 => mode6,  //= Port n.6 mode bits
    27..26 => cnf6,  //= Port n.6 configuration               bits
    29..28 => mode7,  //= Port n.7 mode bits
    31..30 => cnf7,  //= Port n.7 configuration               bits
  },
  0x04 => reg32 crh {  //! Port configuration register high           (GPIOn_CRL)
    1..0 => mode8,  //= Port n.8 mode bits
    3..2 => cnf8,  //= Port n.8 configuration               bits
    5..4 => mode9,  //= Port n.9 mode bits
    7..6 => cnf9,  //= Port n.9 configuration               bits
    9..8 => mode10,  //= Port n.10 mode bits
    11..10 => cnf10,  //= Port n.10 configuration               bits
    13..12 => mode11,  //= Port n.11 mode bits
    15..14 => cnf11,  //= Port n.11 configuration               bits
    17..16 => mode12,  //= Port n.12 mode bits
    19..18 => cnf12,  //= Port n.12 configuration               bits
    21..20 => mode13,  //= Port n.13 mode bits
    23..22 => cnf13,  //= Port n.13 configuration               bits
    25..24 => mode14,  //= Port n.14 mode bits
    27..26 => cnf14,  //= Port n.14 configuration               bits
    29..28 => mode15,  //= Port n.15 mode bits
    31..30 => cnf15,  //= Port n.15 configuration               bits
  },
  0x08 => reg32 idr {  //! Port input data register           (GPIOn_IDR)
    0 => idr0: ro,  //= Port input data
    1 => idr1: ro,  //= Port input data
    2 => idr2: ro,  //= Port input data
    3 => idr3: ro,  //= Port input data
    4 => idr4: ro,  //= Port input data
    5 => idr5: ro,  //= Port input data
    6 => idr6: ro,  //= Port input data
    7 => idr7: ro,  //= Port input data
    8 => idr8: ro,  //= Port input data
    9 => idr9: ro,  //= Port input data
    10 => idr10: ro,  //= Port input data
    11 => idr11: ro,  //= Port input data
    12 => idr12: ro,  //= Port input data
    13 => idr13: ro,  //= Port input data
    14 => idr14: ro,  //= Port input data
    15 => idr15: ro,  //= Port input data
  },
  0x0c => reg32 odr {  //! Port output data register           (GPIOn_ODR)
    0 => odr0,  //= Port output data
    1 => odr1,  //= Port output data
    2 => odr2,  //= Port output data
    3 => odr3,  //= Port output data
    4 => odr4,  //= Port output data
    5 => odr5,  //= Port output data
    6 => odr6,  //= Port output data
    7 => odr7,  //= Port output data
    8 => odr8,  //= Port output data
    9 => odr9,  //= Port output data
    10 => odr10,  //= Port output data
    11 => odr11,  //= Port output data
    12 => odr12,  //= Port output data
    13 => odr13,  //= Port output data
    14 => odr14,  //= Port output data
    15 => odr15,  //= Port output data
  },
  0x10 => reg32 bsrr {  //! Port bit set/reset register           (GPIOn_BSRR)
    0 => bs0: wo,  //= Set bit 0
    1 => bs1: wo,  //= Set bit 1
    2 => bs2: wo,  //= Set bit 1
    3 => bs3: wo,  //= Set bit 3
    4 => bs4: wo,  //= Set bit 4
    5 => bs5: wo,  //= Set bit 5
    6 => bs6: wo,  //= Set bit 6
    7 => bs7: wo,  //= Set bit 7
    8 => bs8: wo,  //= Set bit 8
    9 => bs9: wo,  //= Set bit 9
    10 => bs10: wo,  //= Set bit 10
    11 => bs11: wo,  //= Set bit 11
    12 => bs12: wo,  //= Set bit 12
    13 => bs13: wo,  //= Set bit 13
    14 => bs14: wo,  //= Set bit 14
    15 => bs15: wo,  //= Set bit 15
    16 => br0: wo,  //= Reset bit 0
    17 => br1: wo,  //= Reset bit 1
    18 => br2: wo,  //= Reset bit 2
    19 => br3: wo,  //= Reset bit 3
    20 => br4: wo,  //= Reset bit 4
    21 => br5: wo,  //= Reset bit 5
    22 => br6: wo,  //= Reset bit 6
    23 => br7: wo,  //= Reset bit 7
    24 => br8: wo,  //= Reset bit 8
    25 => br9: wo,  //= Reset bit 9
    26 => br10: wo,  //= Reset bit 10
    27 => br11: wo,  //= Reset bit 11
    28 => br12: wo,  //= Reset bit 12
    29 => br13: wo,  //= Reset bit 13
    30 => br14: wo,  //= Reset bit 14
    31 => br15: wo,  //= Reset bit 15
  },
  0x14 => reg32 brr {  //! Port bit reset register           (GPIOn_BRR)
    0 => br0: wo,  //= Reset bit 0
    1 => br1: wo,  //= Reset bit 1
    2 => br2: wo,  //= Reset bit 1
    3 => br3: wo,  //= Reset bit 3
    4 => br4: wo,  //= Reset bit 4
    5 => br5: wo,  //= Reset bit 5
    6 => br6: wo,  //= Reset bit 6
    7 => br7: wo,  //= Reset bit 7
    8 => br8: wo,  //= Reset bit 8
    9 => br9: wo,  //= Reset bit 9
    10 => br10: wo,  //= Reset bit 10
    11 => br11: wo,  //= Reset bit 11
    12 => br12: wo,  //= Reset bit 12
    13 => br13: wo,  //= Reset bit 13
    14 => br14: wo,  //= Reset bit 14
    15 => br15: wo,  //= Reset bit 15
  },
  0x18 => reg32 lckr {  //! Port configuration lock           register
    0 => lck0,  //= Port A Lock bit 0
    1 => lck1,  //= Port A Lock bit 1
    2 => lck2,  //= Port A Lock bit 2
    3 => lck3,  //= Port A Lock bit 3
    4 => lck4,  //= Port A Lock bit 4
    5 => lck5,  //= Port A Lock bit 5
    6 => lck6,  //= Port A Lock bit 6
    7 => lck7,  //= Port A Lock bit 7
    8 => lck8,  //= Port A Lock bit 8
    9 => lck9,  //= Port A Lock bit 9
    10 => lck10,  //= Port A Lock bit 10
    11 => lck11,  //= Port A Lock bit 11
    12 => lck12,  //= Port A Lock bit 12
    13 => lck13,  //= Port A Lock bit 13
    14 => lck14,  //= Port A Lock bit 14
    15 => lck15,  //= Port A Lock bit 15
    16 => lckk,  //= Lock key
  },
});
ioregs! (AFIO @ 0x40010000 = {  //! Alternate function I/O
  0x00 => reg32 evcr {  //! Event Control Register           (AFIO_EVCR)
    3..0 => pin,  //= Pin selection
    6..4 => port,  //= Port selection
    7 => evoe,  //= Event Output Enable
  },
  0x04 => reg32 mapr {  //! AF remap and debug I/O configuration           register (AFIO_MAPR)
    0 => spi1_remap,  //= SPI1 remapping
    1 => i2c1_remap,  //= I2C1 remapping
    2 => usart1_remap,  //= USART1 remapping
    3 => usart2_remap,  //= USART2 remapping
    5..4 => usart3_remap,  //= USART3 remapping
    7..6 => tim1_remap,  //= TIM1 remapping
    9..8 => tim2_remap,  //= TIM2 remapping
    11..10 => tim3_remap,  //= TIM3 remapping
    12 => tim4_remap,  //= TIM4 remapping
    14..13 => can_remap,  //= CAN1 remapping
    15 => pd01_remap,  //= Port D0/Port D1 mapping on               OSCIN/OSCOUT
    16 => tim5ch4_iremap,  //= Set and cleared by               software
    17 => adc1_etrginj_remap,  //= ADC 1 External trigger injected               conversion remapping
    18 => adc1_etrgreg_remap,  //= ADC 1 external trigger regular               conversion remapping
    19 => adc2_etrginj_remap,  //= ADC 2 external trigger injected               conversion remapping
    20 => adc2_etrgreg_remap,  //= ADC 2 external trigger regular               conversion remapping
    26..24 => swj_cfg: wo,  //= Serial wire JTAG               configuration
  },
  0x08 => reg32 exticr1 {  //! External interrupt configuration register 1           (AFIO_EXTICR1)
    3..0 => exti0,  //= EXTI0 configuration
    7..4 => exti1,  //= EXTI1 configuration
    11..8 => exti2,  //= EXTI2 configuration
    15..12 => exti3,  //= EXTI3 configuration
  },
  0x0c => reg32 exticr2 {  //! External interrupt configuration register 2           (AFIO_EXTICR2)
    3..0 => exti4,  //= EXTI4 configuration
    7..4 => exti5,  //= EXTI5 configuration
    11..8 => exti6,  //= EXTI6 configuration
    15..12 => exti7,  //= EXTI7 configuration
  },
  0x10 => reg32 exticr3 {  //! External interrupt configuration register 3           (AFIO_EXTICR3)
    3..0 => exti8,  //= EXTI8 configuration
    7..4 => exti9,  //= EXTI9 configuration
    11..8 => exti10,  //= EXTI10 configuration
    15..12 => exti11,  //= EXTI11 configuration
  },
  0x14 => reg32 exticr4 {  //! External interrupt configuration register 4           (AFIO_EXTICR4)
    3..0 => exti12,  //= EXTI12 configuration
    7..4 => exti13,  //= EXTI13 configuration
    11..8 => exti14,  //= EXTI14 configuration
    15..12 => exti15,  //= EXTI15 configuration
  },
  0x1c => reg32 mapr2 {  //! AF remap and debug I/O configuration           register
    5 => tim9_remap,  //= TIM9 remapping
    6 => tim10_remap,  //= TIM10 remapping
    7 => tim11_remap,  //= TIM11 remapping
    8 => tim13_remap,  //= TIM13 remapping
    9 => tim14_remap,  //= TIM14 remapping
    10 => fsmc_nadv,  //= NADV connect/disconnect
  },
});
ioregs! (EXTI @ 0x40010400 = {  //! EXTI
  0x00 => reg32 imr {  //! Interrupt mask register           (EXTI_IMR)
    0 => mr0,  //= Interrupt Mask on line 0
    1 => mr1,  //= Interrupt Mask on line 1
    2 => mr2,  //= Interrupt Mask on line 2
    3 => mr3,  //= Interrupt Mask on line 3
    4 => mr4,  //= Interrupt Mask on line 4
    5 => mr5,  //= Interrupt Mask on line 5
    6 => mr6,  //= Interrupt Mask on line 6
    7 => mr7,  //= Interrupt Mask on line 7
    8 => mr8,  //= Interrupt Mask on line 8
    9 => mr9,  //= Interrupt Mask on line 9
    10 => mr10,  //= Interrupt Mask on line 10
    11 => mr11,  //= Interrupt Mask on line 11
    12 => mr12,  //= Interrupt Mask on line 12
    13 => mr13,  //= Interrupt Mask on line 13
    14 => mr14,  //= Interrupt Mask on line 14
    15 => mr15,  //= Interrupt Mask on line 15
    16 => mr16,  //= Interrupt Mask on line 16
    17 => mr17,  //= Interrupt Mask on line 17
    18 => mr18,  //= Interrupt Mask on line 18
  },
  0x04 => reg32 emr {  //! Event mask register (EXTI_EMR)
    0 => mr0,  //= Event Mask on line 0
    1 => mr1,  //= Event Mask on line 1
    2 => mr2,  //= Event Mask on line 2
    3 => mr3,  //= Event Mask on line 3
    4 => mr4,  //= Event Mask on line 4
    5 => mr5,  //= Event Mask on line 5
    6 => mr6,  //= Event Mask on line 6
    7 => mr7,  //= Event Mask on line 7
    8 => mr8,  //= Event Mask on line 8
    9 => mr9,  //= Event Mask on line 9
    10 => mr10,  //= Event Mask on line 10
    11 => mr11,  //= Event Mask on line 11
    12 => mr12,  //= Event Mask on line 12
    13 => mr13,  //= Event Mask on line 13
    14 => mr14,  //= Event Mask on line 14
    15 => mr15,  //= Event Mask on line 15
    16 => mr16,  //= Event Mask on line 16
    17 => mr17,  //= Event Mask on line 17
    18 => mr18,  //= Event Mask on line 18
  },
  0x08 => reg32 rtsr {  //! Rising Trigger selection register           (EXTI_RTSR)
    0 => tr0,  //= Rising trigger event configuration of               line 0
    1 => tr1,  //= Rising trigger event configuration of               line 1
    2 => tr2,  //= Rising trigger event configuration of               line 2
    3 => tr3,  //= Rising trigger event configuration of               line 3
    4 => tr4,  //= Rising trigger event configuration of               line 4
    5 => tr5,  //= Rising trigger event configuration of               line 5
    6 => tr6,  //= Rising trigger event configuration of               line 6
    7 => tr7,  //= Rising trigger event configuration of               line 7
    8 => tr8,  //= Rising trigger event configuration of               line 8
    9 => tr9,  //= Rising trigger event configuration of               line 9
    10 => tr10,  //= Rising trigger event configuration of               line 10
    11 => tr11,  //= Rising trigger event configuration of               line 11
    12 => tr12,  //= Rising trigger event configuration of               line 12
    13 => tr13,  //= Rising trigger event configuration of               line 13
    14 => tr14,  //= Rising trigger event configuration of               line 14
    15 => tr15,  //= Rising trigger event configuration of               line 15
    16 => tr16,  //= Rising trigger event configuration of               line 16
    17 => tr17,  //= Rising trigger event configuration of               line 17
    18 => tr18,  //= Rising trigger event configuration of               line 18
  },
  0x0c => reg32 ftsr {  //! Falling Trigger selection register           (EXTI_FTSR)
    0 => tr0,  //= Falling trigger event configuration of               line 0
    1 => tr1,  //= Falling trigger event configuration of               line 1
    2 => tr2,  //= Falling trigger event configuration of               line 2
    3 => tr3,  //= Falling trigger event configuration of               line 3
    4 => tr4,  //= Falling trigger event configuration of               line 4
    5 => tr5,  //= Falling trigger event configuration of               line 5
    6 => tr6,  //= Falling trigger event configuration of               line 6
    7 => tr7,  //= Falling trigger event configuration of               line 7
    8 => tr8,  //= Falling trigger event configuration of               line 8
    9 => tr9,  //= Falling trigger event configuration of               line 9
    10 => tr10,  //= Falling trigger event configuration of               line 10
    11 => tr11,  //= Falling trigger event configuration of               line 11
    12 => tr12,  //= Falling trigger event configuration of               line 12
    13 => tr13,  //= Falling trigger event configuration of               line 13
    14 => tr14,  //= Falling trigger event configuration of               line 14
    15 => tr15,  //= Falling trigger event configuration of               line 15
    16 => tr16,  //= Falling trigger event configuration of               line 16
    17 => tr17,  //= Falling trigger event configuration of               line 17
    18 => tr18,  //= Falling trigger event configuration of               line 18
  },
  0x10 => reg32 swier {  //! Software interrupt event register           (EXTI_SWIER)
    0 => swier0,  //= Software Interrupt on line               0
    1 => swier1,  //= Software Interrupt on line               1
    2 => swier2,  //= Software Interrupt on line               2
    3 => swier3,  //= Software Interrupt on line               3
    4 => swier4,  //= Software Interrupt on line               4
    5 => swier5,  //= Software Interrupt on line               5
    6 => swier6,  //= Software Interrupt on line               6
    7 => swier7,  //= Software Interrupt on line               7
    8 => swier8,  //= Software Interrupt on line               8
    9 => swier9,  //= Software Interrupt on line               9
    10 => swier10,  //= Software Interrupt on line               10
    11 => swier11,  //= Software Interrupt on line               11
    12 => swier12,  //= Software Interrupt on line               12
    13 => swier13,  //= Software Interrupt on line               13
    14 => swier14,  //= Software Interrupt on line               14
    15 => swier15,  //= Software Interrupt on line               15
    16 => swier16,  //= Software Interrupt on line               16
    17 => swier17,  //= Software Interrupt on line               17
    18 => swier18,  //= Software Interrupt on line               18
  },
  0x14 => reg32 pr {  //! Pending register (EXTI_PR)
    0 => pr0,  //= Pending bit 0
    1 => pr1,  //= Pending bit 1
    2 => pr2,  //= Pending bit 2
    3 => pr3,  //= Pending bit 3
    4 => pr4,  //= Pending bit 4
    5 => pr5,  //= Pending bit 5
    6 => pr6,  //= Pending bit 6
    7 => pr7,  //= Pending bit 7
    8 => pr8,  //= Pending bit 8
    9 => pr9,  //= Pending bit 9
    10 => pr10,  //= Pending bit 10
    11 => pr11,  //= Pending bit 11
    12 => pr12,  //= Pending bit 12
    13 => pr13,  //= Pending bit 13
    14 => pr14,  //= Pending bit 14
    15 => pr15,  //= Pending bit 15
    16 => pr16,  //= Pending bit 16
    17 => pr17,  //= Pending bit 17
    18 => pr18,  //= Pending bit 18
  },
});
ioregs! (DMA1 @ 0x40020000 = {  //! DMA controller
  0x00 => reg32 isr {  //! DMA interrupt status register           (DMA_ISR)
    0 => gif1: ro,  //= Channel 1 Global interrupt               flag
    1 => tcif1: ro,  //= Channel 1 Transfer Complete               flag
    2 => htif1: ro,  //= Channel 1 Half Transfer Complete               flag
    3 => teif1: ro,  //= Channel 1 Transfer Error               flag
    4 => gif2: ro,  //= Channel 2 Global interrupt               flag
    5 => tcif2: ro,  //= Channel 2 Transfer Complete               flag
    6 => htif2: ro,  //= Channel 2 Half Transfer Complete               flag
    7 => teif2: ro,  //= Channel 2 Transfer Error               flag
    8 => gif3: ro,  //= Channel 3 Global interrupt               flag
    9 => tcif3: ro,  //= Channel 3 Transfer Complete               flag
    10 => htif3: ro,  //= Channel 3 Half Transfer Complete               flag
    11 => teif3: ro,  //= Channel 3 Transfer Error               flag
    12 => gif4: ro,  //= Channel 4 Global interrupt               flag
    13 => tcif4: ro,  //= Channel 4 Transfer Complete               flag
    14 => htif4: ro,  //= Channel 4 Half Transfer Complete               flag
    15 => teif4: ro,  //= Channel 4 Transfer Error               flag
    16 => gif5: ro,  //= Channel 5 Global interrupt               flag
    17 => tcif5: ro,  //= Channel 5 Transfer Complete               flag
    18 => htif5: ro,  //= Channel 5 Half Transfer Complete               flag
    19 => teif5: ro,  //= Channel 5 Transfer Error               flag
    20 => gif6: ro,  //= Channel 6 Global interrupt               flag
    21 => tcif6: ro,  //= Channel 6 Transfer Complete               flag
    22 => htif6: ro,  //= Channel 6 Half Transfer Complete               flag
    23 => teif6: ro,  //= Channel 6 Transfer Error               flag
    24 => gif7: ro,  //= Channel 7 Global interrupt               flag
    25 => tcif7: ro,  //= Channel 7 Transfer Complete               flag
    26 => htif7: ro,  //= Channel 7 Half Transfer Complete               flag
    27 => teif7: ro,  //= Channel 7 Transfer Error               flag
  },
  0x04 => reg32 ifcr {  //! DMA interrupt flag clear register           (DMA_IFCR)
    0 => cgif1: wo,  //= Channel 1 Global interrupt               clear
    4 => cgif2: wo,  //= Channel 2 Global interrupt               clear
    8 => cgif3: wo,  //= Channel 3 Global interrupt               clear
    12 => cgif4: wo,  //= Channel 4 Global interrupt               clear
    16 => cgif5: wo,  //= Channel 5 Global interrupt               clear
    20 => cgif6: wo,  //= Channel 6 Global interrupt               clear
    24 => cgif7: wo,  //= Channel 7 Global interrupt               clear
    1 => ctcif1: wo,  //= Channel 1 Transfer Complete               clear
    5 => ctcif2: wo,  //= Channel 2 Transfer Complete               clear
    9 => ctcif3: wo,  //= Channel 3 Transfer Complete               clear
    13 => ctcif4: wo,  //= Channel 4 Transfer Complete               clear
    17 => ctcif5: wo,  //= Channel 5 Transfer Complete               clear
    21 => ctcif6: wo,  //= Channel 6 Transfer Complete               clear
    25 => ctcif7: wo,  //= Channel 7 Transfer Complete               clear
    2 => chtif1: wo,  //= Channel 1 Half Transfer               clear
    6 => chtif2: wo,  //= Channel 2 Half Transfer               clear
    10 => chtif3: wo,  //= Channel 3 Half Transfer               clear
    14 => chtif4: wo,  //= Channel 4 Half Transfer               clear
    18 => chtif5: wo,  //= Channel 5 Half Transfer               clear
    22 => chtif6: wo,  //= Channel 6 Half Transfer               clear
    26 => chtif7: wo,  //= Channel 7 Half Transfer               clear
    3 => cteif1: wo,  //= Channel 1 Transfer Error               clear
    7 => cteif2: wo,  //= Channel 2 Transfer Error               clear
    11 => cteif3: wo,  //= Channel 3 Transfer Error               clear
    15 => cteif4: wo,  //= Channel 4 Transfer Error               clear
    19 => cteif5: wo,  //= Channel 5 Transfer Error               clear
    23 => cteif6: wo,  //= Channel 6 Transfer Error               clear
    27 => cteif7: wo,  //= Channel 7 Transfer Error               clear
  },
  0x08 => reg32 ccr1 {  //! DMA channel configuration register           (DMA_CCR)
    0 => en,  //= Channel enable
    1 => tcie,  //= Transfer complete interrupt               enable
    2 => htie,  //= Half Transfer interrupt               enable
    3 => teie,  //= Transfer error interrupt               enable
    4 => dir,  //= Data transfer direction
    5 => circ,  //= Circular mode
    6 => pinc,  //= Peripheral increment mode
    7 => minc,  //= Memory increment mode
    9..8 => psize,  //= Peripheral size
    11..10 => msize,  //= Memory size
    13..12 => pl,  //= Channel Priority level
    14 => mem2mem,  //= Memory to memory mode
  },
  0x0c => reg32 cndtr1 {  //! DMA channel 1 number of data           register
    15..0 => ndt,  //= Number of data to transfer
  },
  0x10 => reg32 cpar1 {  //! DMA channel 1 peripheral address           register
    31..0 => pa,  //= Peripheral address
  },
  0x14 => reg32 cmar1 {  //! DMA channel 1 memory address           register
    31..0 => ma,  //= Memory address
  },
  0x1c => reg32 ccr2 {  //! DMA channel configuration register           (DMA_CCR)
    0 => en,  //= Channel enable
    1 => tcie,  //= Transfer complete interrupt               enable
    2 => htie,  //= Half Transfer interrupt               enable
    3 => teie,  //= Transfer error interrupt               enable
    4 => dir,  //= Data transfer direction
    5 => circ,  //= Circular mode
    6 => pinc,  //= Peripheral increment mode
    7 => minc,  //= Memory increment mode
    9..8 => psize,  //= Peripheral size
    11..10 => msize,  //= Memory size
    13..12 => pl,  //= Channel Priority level
    14 => mem2mem,  //= Memory to memory mode
  },
  0x20 => reg32 cndtr2 {  //! DMA channel 2 number of data           register
    15..0 => ndt,  //= Number of data to transfer
  },
  0x24 => reg32 cpar2 {  //! DMA channel 2 peripheral address           register
    31..0 => pa,  //= Peripheral address
  },
  0x28 => reg32 cmar2 {  //! DMA channel 2 memory address           register
    31..0 => ma,  //= Memory address
  },
  0x30 => reg32 ccr3 {  //! DMA channel configuration register           (DMA_CCR)
    0 => en,  //= Channel enable
    1 => tcie,  //= Transfer complete interrupt               enable
    2 => htie,  //= Half Transfer interrupt               enable
    3 => teie,  //= Transfer error interrupt               enable
    4 => dir,  //= Data transfer direction
    5 => circ,  //= Circular mode
    6 => pinc,  //= Peripheral increment mode
    7 => minc,  //= Memory increment mode
    9..8 => psize,  //= Peripheral size
    11..10 => msize,  //= Memory size
    13..12 => pl,  //= Channel Priority level
    14 => mem2mem,  //= Memory to memory mode
  },
  0x34 => reg32 cndtr3 {  //! DMA channel 3 number of data           register
    15..0 => ndt,  //= Number of data to transfer
  },
  0x38 => reg32 cpar3 {  //! DMA channel 3 peripheral address           register
    31..0 => pa,  //= Peripheral address
  },
  0x3c => reg32 cmar3 {  //! DMA channel 3 memory address           register
    31..0 => ma,  //= Memory address
  },
  0x44 => reg32 ccr4 {  //! DMA channel configuration register           (DMA_CCR)
    0 => en,  //= Channel enable
    1 => tcie,  //= Transfer complete interrupt               enable
    2 => htie,  //= Half Transfer interrupt               enable
    3 => teie,  //= Transfer error interrupt               enable
    4 => dir,  //= Data transfer direction
    5 => circ,  //= Circular mode
    6 => pinc,  //= Peripheral increment mode
    7 => minc,  //= Memory increment mode
    9..8 => psize,  //= Peripheral size
    11..10 => msize,  //= Memory size
    13..12 => pl,  //= Channel Priority level
    14 => mem2mem,  //= Memory to memory mode
  },
  0x48 => reg32 cndtr4 {  //! DMA channel 4 number of data           register
    15..0 => ndt,  //= Number of data to transfer
  },
  0x4c => reg32 cpar4 {  //! DMA channel 4 peripheral address           register
    31..0 => pa,  //= Peripheral address
  },
  0x50 => reg32 cmar4 {  //! DMA channel 4 memory address           register
    31..0 => ma,  //= Memory address
  },
  0x58 => reg32 ccr5 {  //! DMA channel configuration register           (DMA_CCR)
    0 => en,  //= Channel enable
    1 => tcie,  //= Transfer complete interrupt               enable
    2 => htie,  //= Half Transfer interrupt               enable
    3 => teie,  //= Transfer error interrupt               enable
    4 => dir,  //= Data transfer direction
    5 => circ,  //= Circular mode
    6 => pinc,  //= Peripheral increment mode
    7 => minc,  //= Memory increment mode
    9..8 => psize,  //= Peripheral size
    11..10 => msize,  //= Memory size
    13..12 => pl,  //= Channel Priority level
    14 => mem2mem,  //= Memory to memory mode
  },
  0x5c => reg32 cndtr5 {  //! DMA channel 5 number of data           register
    15..0 => ndt,  //= Number of data to transfer
  },
  0x60 => reg32 cpar5 {  //! DMA channel 5 peripheral address           register
    31..0 => pa,  //= Peripheral address
  },
  0x64 => reg32 cmar5 {  //! DMA channel 5 memory address           register
    31..0 => ma,  //= Memory address
  },
  0x6c => reg32 ccr6 {  //! DMA channel configuration register           (DMA_CCR)
    0 => en,  //= Channel enable
    1 => tcie,  //= Transfer complete interrupt               enable
    2 => htie,  //= Half Transfer interrupt               enable
    3 => teie,  //= Transfer error interrupt               enable
    4 => dir,  //= Data transfer direction
    5 => circ,  //= Circular mode
    6 => pinc,  //= Peripheral increment mode
    7 => minc,  //= Memory increment mode
    9..8 => psize,  //= Peripheral size
    11..10 => msize,  //= Memory size
    13..12 => pl,  //= Channel Priority level
    14 => mem2mem,  //= Memory to memory mode
  },
  0x70 => reg32 cndtr6 {  //! DMA channel 6 number of data           register
    15..0 => ndt,  //= Number of data to transfer
  },
  0x74 => reg32 cpar6 {  //! DMA channel 6 peripheral address           register
    31..0 => pa,  //= Peripheral address
  },
  0x78 => reg32 cmar6 {  //! DMA channel 6 memory address           register
    31..0 => ma,  //= Memory address
  },
  0x80 => reg32 ccr7 {  //! DMA channel configuration register           (DMA_CCR)
    0 => en,  //= Channel enable
    1 => tcie,  //= Transfer complete interrupt               enable
    2 => htie,  //= Half Transfer interrupt               enable
    3 => teie,  //= Transfer error interrupt               enable
    4 => dir,  //= Data transfer direction
    5 => circ,  //= Circular mode
    6 => pinc,  //= Peripheral increment mode
    7 => minc,  //= Memory increment mode
    9..8 => psize,  //= Peripheral size
    11..10 => msize,  //= Memory size
    13..12 => pl,  //= Channel Priority level
    14 => mem2mem,  //= Memory to memory mode
  },
  0x84 => reg32 cndtr7 {  //! DMA channel 7 number of data           register
    15..0 => ndt,  //= Number of data to transfer
  },
  0x88 => reg32 cpar7 {  //! DMA channel 7 peripheral address           register
    31..0 => pa,  //= Peripheral address
  },
  0x8c => reg32 cmar7 {  //! DMA channel 7 memory address           register
    31..0 => ma,  //= Memory address
  },
});
ioregs! (DMA2 @ 0x40020400 = {  //! DMA controller
  0x00 => reg32 isr {  //! DMA interrupt status register           (DMA_ISR)
    0 => gif1: ro,  //= Channel 1 Global interrupt               flag
    1 => tcif1: ro,  //= Channel 1 Transfer Complete               flag
    2 => htif1: ro,  //= Channel 1 Half Transfer Complete               flag
    3 => teif1: ro,  //= Channel 1 Transfer Error               flag
    4 => gif2: ro,  //= Channel 2 Global interrupt               flag
    5 => tcif2: ro,  //= Channel 2 Transfer Complete               flag
    6 => htif2: ro,  //= Channel 2 Half Transfer Complete               flag
    7 => teif2: ro,  //= Channel 2 Transfer Error               flag
    8 => gif3: ro,  //= Channel 3 Global interrupt               flag
    9 => tcif3: ro,  //= Channel 3 Transfer Complete               flag
    10 => htif3: ro,  //= Channel 3 Half Transfer Complete               flag
    11 => teif3: ro,  //= Channel 3 Transfer Error               flag
    12 => gif4: ro,  //= Channel 4 Global interrupt               flag
    13 => tcif4: ro,  //= Channel 4 Transfer Complete               flag
    14 => htif4: ro,  //= Channel 4 Half Transfer Complete               flag
    15 => teif4: ro,  //= Channel 4 Transfer Error               flag
    16 => gif5: ro,  //= Channel 5 Global interrupt               flag
    17 => tcif5: ro,  //= Channel 5 Transfer Complete               flag
    18 => htif5: ro,  //= Channel 5 Half Transfer Complete               flag
    19 => teif5: ro,  //= Channel 5 Transfer Error               flag
    20 => gif6: ro,  //= Channel 6 Global interrupt               flag
    21 => tcif6: ro,  //= Channel 6 Transfer Complete               flag
    22 => htif6: ro,  //= Channel 6 Half Transfer Complete               flag
    23 => teif6: ro,  //= Channel 6 Transfer Error               flag
    24 => gif7: ro,  //= Channel 7 Global interrupt               flag
    25 => tcif7: ro,  //= Channel 7 Transfer Complete               flag
    26 => htif7: ro,  //= Channel 7 Half Transfer Complete               flag
    27 => teif7: ro,  //= Channel 7 Transfer Error               flag
  },
  0x04 => reg32 ifcr {  //! DMA interrupt flag clear register           (DMA_IFCR)
    0 => cgif1: wo,  //= Channel 1 Global interrupt               clear
    4 => cgif2: wo,  //= Channel 2 Global interrupt               clear
    8 => cgif3: wo,  //= Channel 3 Global interrupt               clear
    12 => cgif4: wo,  //= Channel 4 Global interrupt               clear
    16 => cgif5: wo,  //= Channel 5 Global interrupt               clear
    20 => cgif6: wo,  //= Channel 6 Global interrupt               clear
    24 => cgif7: wo,  //= Channel 7 Global interrupt               clear
    1 => ctcif1: wo,  //= Channel 1 Transfer Complete               clear
    5 => ctcif2: wo,  //= Channel 2 Transfer Complete               clear
    9 => ctcif3: wo,  //= Channel 3 Transfer Complete               clear
    13 => ctcif4: wo,  //= Channel 4 Transfer Complete               clear
    17 => ctcif5: wo,  //= Channel 5 Transfer Complete               clear
    21 => ctcif6: wo,  //= Channel 6 Transfer Complete               clear
    25 => ctcif7: wo,  //= Channel 7 Transfer Complete               clear
    2 => chtif1: wo,  //= Channel 1 Half Transfer               clear
    6 => chtif2: wo,  //= Channel 2 Half Transfer               clear
    10 => chtif3: wo,  //= Channel 3 Half Transfer               clear
    14 => chtif4: wo,  //= Channel 4 Half Transfer               clear
    18 => chtif5: wo,  //= Channel 5 Half Transfer               clear
    22 => chtif6: wo,  //= Channel 6 Half Transfer               clear
    26 => chtif7: wo,  //= Channel 7 Half Transfer               clear
    3 => cteif1: wo,  //= Channel 1 Transfer Error               clear
    7 => cteif2: wo,  //= Channel 2 Transfer Error               clear
    11 => cteif3: wo,  //= Channel 3 Transfer Error               clear
    15 => cteif4: wo,  //= Channel 4 Transfer Error               clear
    19 => cteif5: wo,  //= Channel 5 Transfer Error               clear
    23 => cteif6: wo,  //= Channel 6 Transfer Error               clear
    27 => cteif7: wo,  //= Channel 7 Transfer Error               clear
  },
  0x08 => reg32 ccr1 {  //! DMA channel configuration register           (DMA_CCR)
    0 => en,  //= Channel enable
    1 => tcie,  //= Transfer complete interrupt               enable
    2 => htie,  //= Half Transfer interrupt               enable
    3 => teie,  //= Transfer error interrupt               enable
    4 => dir,  //= Data transfer direction
    5 => circ,  //= Circular mode
    6 => pinc,  //= Peripheral increment mode
    7 => minc,  //= Memory increment mode
    9..8 => psize,  //= Peripheral size
    11..10 => msize,  //= Memory size
    13..12 => pl,  //= Channel Priority level
    14 => mem2mem,  //= Memory to memory mode
  },
  0x0c => reg32 cndtr1 {  //! DMA channel 1 number of data           register
    15..0 => ndt,  //= Number of data to transfer
  },
  0x10 => reg32 cpar1 {  //! DMA channel 1 peripheral address           register
    31..0 => pa,  //= Peripheral address
  },
  0x14 => reg32 cmar1 {  //! DMA channel 1 memory address           register
    31..0 => ma,  //= Memory address
  },
  0x1c => reg32 ccr2 {  //! DMA channel configuration register           (DMA_CCR)
    0 => en,  //= Channel enable
    1 => tcie,  //= Transfer complete interrupt               enable
    2 => htie,  //= Half Transfer interrupt               enable
    3 => teie,  //= Transfer error interrupt               enable
    4 => dir,  //= Data transfer direction
    5 => circ,  //= Circular mode
    6 => pinc,  //= Peripheral increment mode
    7 => minc,  //= Memory increment mode
    9..8 => psize,  //= Peripheral size
    11..10 => msize,  //= Memory size
    13..12 => pl,  //= Channel Priority level
    14 => mem2mem,  //= Memory to memory mode
  },
  0x20 => reg32 cndtr2 {  //! DMA channel 2 number of data           register
    15..0 => ndt,  //= Number of data to transfer
  },
  0x24 => reg32 cpar2 {  //! DMA channel 2 peripheral address           register
    31..0 => pa,  //= Peripheral address
  },
  0x28 => reg32 cmar2 {  //! DMA channel 2 memory address           register
    31..0 => ma,  //= Memory address
  },
  0x30 => reg32 ccr3 {  //! DMA channel configuration register           (DMA_CCR)
    0 => en,  //= Channel enable
    1 => tcie,  //= Transfer complete interrupt               enable
    2 => htie,  //= Half Transfer interrupt               enable
    3 => teie,  //= Transfer error interrupt               enable
    4 => dir,  //= Data transfer direction
    5 => circ,  //= Circular mode
    6 => pinc,  //= Peripheral increment mode
    7 => minc,  //= Memory increment mode
    9..8 => psize,  //= Peripheral size
    11..10 => msize,  //= Memory size
    13..12 => pl,  //= Channel Priority level
    14 => mem2mem,  //= Memory to memory mode
  },
  0x34 => reg32 cndtr3 {  //! DMA channel 3 number of data           register
    15..0 => ndt,  //= Number of data to transfer
  },
  0x38 => reg32 cpar3 {  //! DMA channel 3 peripheral address           register
    31..0 => pa,  //= Peripheral address
  },
  0x3c => reg32 cmar3 {  //! DMA channel 3 memory address           register
    31..0 => ma,  //= Memory address
  },
  0x44 => reg32 ccr4 {  //! DMA channel configuration register           (DMA_CCR)
    0 => en,  //= Channel enable
    1 => tcie,  //= Transfer complete interrupt               enable
    2 => htie,  //= Half Transfer interrupt               enable
    3 => teie,  //= Transfer error interrupt               enable
    4 => dir,  //= Data transfer direction
    5 => circ,  //= Circular mode
    6 => pinc,  //= Peripheral increment mode
    7 => minc,  //= Memory increment mode
    9..8 => psize,  //= Peripheral size
    11..10 => msize,  //= Memory size
    13..12 => pl,  //= Channel Priority level
    14 => mem2mem,  //= Memory to memory mode
  },
  0x48 => reg32 cndtr4 {  //! DMA channel 4 number of data           register
    15..0 => ndt,  //= Number of data to transfer
  },
  0x4c => reg32 cpar4 {  //! DMA channel 4 peripheral address           register
    31..0 => pa,  //= Peripheral address
  },
  0x50 => reg32 cmar4 {  //! DMA channel 4 memory address           register
    31..0 => ma,  //= Memory address
  },
  0x58 => reg32 ccr5 {  //! DMA channel configuration register           (DMA_CCR)
    0 => en,  //= Channel enable
    1 => tcie,  //= Transfer complete interrupt               enable
    2 => htie,  //= Half Transfer interrupt               enable
    3 => teie,  //= Transfer error interrupt               enable
    4 => dir,  //= Data transfer direction
    5 => circ,  //= Circular mode
    6 => pinc,  //= Peripheral increment mode
    7 => minc,  //= Memory increment mode
    9..8 => psize,  //= Peripheral size
    11..10 => msize,  //= Memory size
    13..12 => pl,  //= Channel Priority level
    14 => mem2mem,  //= Memory to memory mode
  },
  0x5c => reg32 cndtr5 {  //! DMA channel 5 number of data           register
    15..0 => ndt,  //= Number of data to transfer
  },
  0x60 => reg32 cpar5 {  //! DMA channel 5 peripheral address           register
    31..0 => pa,  //= Peripheral address
  },
  0x64 => reg32 cmar5 {  //! DMA channel 5 memory address           register
    31..0 => ma,  //= Memory address
  },
  0x6c => reg32 ccr6 {  //! DMA channel configuration register           (DMA_CCR)
    0 => en,  //= Channel enable
    1 => tcie,  //= Transfer complete interrupt               enable
    2 => htie,  //= Half Transfer interrupt               enable
    3 => teie,  //= Transfer error interrupt               enable
    4 => dir,  //= Data transfer direction
    5 => circ,  //= Circular mode
    6 => pinc,  //= Peripheral increment mode
    7 => minc,  //= Memory increment mode
    9..8 => psize,  //= Peripheral size
    11..10 => msize,  //= Memory size
    13..12 => pl,  //= Channel Priority level
    14 => mem2mem,  //= Memory to memory mode
  },
  0x70 => reg32 cndtr6 {  //! DMA channel 6 number of data           register
    15..0 => ndt,  //= Number of data to transfer
  },
  0x74 => reg32 cpar6 {  //! DMA channel 6 peripheral address           register
    31..0 => pa,  //= Peripheral address
  },
  0x78 => reg32 cmar6 {  //! DMA channel 6 memory address           register
    31..0 => ma,  //= Memory address
  },
  0x80 => reg32 ccr7 {  //! DMA channel configuration register           (DMA_CCR)
    0 => en,  //= Channel enable
    1 => tcie,  //= Transfer complete interrupt               enable
    2 => htie,  //= Half Transfer interrupt               enable
    3 => teie,  //= Transfer error interrupt               enable
    4 => dir,  //= Data transfer direction
    5 => circ,  //= Circular mode
    6 => pinc,  //= Peripheral increment mode
    7 => minc,  //= Memory increment mode
    9..8 => psize,  //= Peripheral size
    11..10 => msize,  //= Memory size
    13..12 => pl,  //= Channel Priority level
    14 => mem2mem,  //= Memory to memory mode
  },
  0x84 => reg32 cndtr7 {  //! DMA channel 7 number of data           register
    15..0 => ndt,  //= Number of data to transfer
  },
  0x88 => reg32 cpar7 {  //! DMA channel 7 peripheral address           register
    31..0 => pa,  //= Peripheral address
  },
  0x8c => reg32 cmar7 {  //! DMA channel 7 memory address           register
    31..0 => ma,  //= Memory address
  },
});
ioregs! (SDIO @ 0x40018000 = {  //! Secure digital input/output       interface
  0x00 => reg32 power {  //! Bits 1:0 = PWRCTRL: Power supply control           bits
    1..0 => pwrctrl,  //= PWRCTRL
  },
  0x04 => reg32 clkcr {  //! SDI clock control register           (SDIO_CLKCR)
    7..0 => clkdiv,  //= Clock divide factor
    8 => clken,  //= Clock enable bit
    9 => pwrsav,  //= Power saving configuration               bit
    10 => bypass,  //= Clock divider bypass enable               bit
    12..11 => widbus,  //= Wide bus mode enable bit
    13 => negedge,  //= SDIO_CK dephasing selection               bit
    14 => hwfc_en,  //= HW Flow Control enable
  },
  0x08 => reg32 arg {  //! Bits 31:0 = : Command argument
    31..0 => cmdarg,  //= Command argument
  },
  0x0c => reg32 cmd {  //! SDIO command register           (SDIO_CMD)
    5..0 => cmdindex,  //= CMDINDEX
    7..6 => waitresp,  //= WAITRESP
    8 => waitint,  //= WAITINT
    9 => waitpend,  //= WAITPEND
    10 => cpsmen,  //= CPSMEN
    11 => sdiosuspend,  //= SDIOSuspend
    12 => encmdcompl,  //= ENCMDcompl
    13 => nien,  //= nIEN
    14 => ce_atacmd,  //= CE_ATACMD
  },
  0x10 => reg32 respcmd {  //! SDIO command register
    5..0 => respcmd: ro,  //= RESPCMD
  },
  0x14 => reg32 respi1 {  //! Bits 31:0 = CARDSTATUS1
    31..0 => cardstatus1: ro,  //= CARDSTATUS1
  },
  0x18 => reg32 resp2 {  //! Bits 31:0 = CARDSTATUS2
    31..0 => cardstatus2: ro,  //= CARDSTATUS2
  },
  0x1c => reg32 resp3 {  //! Bits 31:0 = CARDSTATUS3
    31..0 => cardstatus3: ro,  //= CARDSTATUS3
  },
  0x20 => reg32 resp4 {  //! Bits 31:0 = CARDSTATUS4
    31..0 => cardstatus4: ro,  //= CARDSTATUS4
  },
  0x24 => reg32 dtimer {  //! Bits 31:0 = DATATIME: Data timeout           period
    31..0 => datatime,  //= Data timeout period
  },
  0x28 => reg32 dlen {  //! Bits 24:0 = DATALENGTH: Data length           value
    24..0 => datalength,  //= Data length value
  },
  0x2c => reg32 dctrl {  //! SDIO data control register           (SDIO_DCTRL)
    0 => dten,  //= DTEN
    1 => dtdir,  //= DTDIR
    2 => dtmode,  //= DTMODE
    3 => dmaen,  //= DMAEN
    7..4 => dblocksize,  //= DBLOCKSIZE
    8 => pwstart,  //= PWSTART
    9 => pwstop,  //= PWSTOP
    10 => rwmod,  //= RWMOD
    11 => sdioen,  //= SDIOEN
  },
  0x30 => reg32 dcount {  //! Bits 24:0 = DATACOUNT: Data count           value
    24..0 => datacount: ro,  //= Data count value
  },
  0x34 => reg32 sta {  //! SDIO status register           (SDIO_STA)
    0 => ccrcfail: ro,  //= CCRCFAIL
    1 => dcrcfail: ro,  //= DCRCFAIL
    2 => ctimeout: ro,  //= CTIMEOUT
    3 => dtimeout: ro,  //= DTIMEOUT
    4 => txunderr: ro,  //= TXUNDERR
    5 => rxoverr: ro,  //= RXOVERR
    6 => cmdrend: ro,  //= CMDREND
    7 => cmdsent: ro,  //= CMDSENT
    8 => dataend: ro,  //= DATAEND
    9 => stbiterr: ro,  //= STBITERR
    10 => dbckend: ro,  //= DBCKEND
    11 => cmdact: ro,  //= CMDACT
    12 => txact: ro,  //= TXACT
    13 => rxact: ro,  //= RXACT
    14 => txfifohe: ro,  //= TXFIFOHE
    15 => rxfifohf: ro,  //= RXFIFOHF
    16 => txfifof: ro,  //= TXFIFOF
    17 => rxfifof: ro,  //= RXFIFOF
    18 => txfifoe: ro,  //= TXFIFOE
    19 => rxfifoe: ro,  //= RXFIFOE
    20 => txdavl: ro,  //= TXDAVL
    21 => rxdavl: ro,  //= RXDAVL
    22 => sdioit: ro,  //= SDIOIT
    23 => ceataend: ro,  //= CEATAEND
  },
  0x38 => reg32 icr {  //! SDIO interrupt clear register           (SDIO_ICR)
    0 => ccrcfailc,  //= CCRCFAILC
    1 => dcrcfailc,  //= DCRCFAILC
    2 => ctimeoutc,  //= CTIMEOUTC
    3 => dtimeoutc,  //= DTIMEOUTC
    4 => txunderrc,  //= TXUNDERRC
    5 => rxoverrc,  //= RXOVERRC
    6 => cmdrendc,  //= CMDRENDC
    7 => cmdsentc,  //= CMDSENTC
    8 => dataendc,  //= DATAENDC
    9 => stbiterrc,  //= STBITERRC
    10 => dbckendc,  //= DBCKENDC
    22 => sdioitc,  //= SDIOITC
    23 => ceataendc,  //= CEATAENDC
  },
  0x3c => reg32 mask {  //! SDIO mask register (SDIO_MASK)
    0 => ccrcfailie,  //= CCRCFAILIE
    1 => dcrcfailie,  //= DCRCFAILIE
    2 => ctimeoutie,  //= CTIMEOUTIE
    3 => dtimeoutie,  //= DTIMEOUTIE
    4 => txunderrie,  //= TXUNDERRIE
    5 => rxoverrie,  //= RXOVERRIE
    6 => cmdrendie,  //= CMDRENDIE
    7 => cmdsentie,  //= CMDSENTIE
    8 => dataendie,  //= DATAENDIE
    9 => stbiterrie,  //= STBITERRIE
    10 => dbackendie,  //= DBACKENDIE
    11 => cmdactie,  //= CMDACTIE
    12 => txactie,  //= TXACTIE
    13 => rxactie,  //= RXACTIE
    14 => txfifoheie,  //= TXFIFOHEIE
    15 => rxfifohfie,  //= RXFIFOHFIE
    16 => txfifofie,  //= TXFIFOFIE
    17 => rxfifofie,  //= RXFIFOFIE
    18 => txfifoeie,  //= TXFIFOEIE
    19 => rxfifoeie,  //= RXFIFOEIE
    20 => txdavlie,  //= TXDAVLIE
    21 => rxdavlie,  //= RXDAVLIE
    22 => sdioitie,  //= SDIOITIE
    23 => ceatendie,  //= CEATENDIE
  },
  0x48 => reg32 fifocnt {  //! Bits 23:0 = FIFOCOUNT: Remaining number of           words to be written to or read from the           FIFO
    23..0 => fif0count: ro,  //= FIF0COUNT
  },
  0x80 => reg32 fifo {  //! bits 31:0 = FIFOData: Receive and transmit           FIFO data
    31..0 => fifodata,  //= FIFOData
  },
});
ioregs! (RTC @ 0x40002800 = {  //! Real time clock
  0x00 => reg32 crh {  //! RTC Control Register High
    0 => secie,  //= Second interrupt Enable
    1 => alrie,  //= Alarm interrupt Enable
    2 => owie,  //= Overflow interrupt Enable
  },
  0x04 => reg32 crl {  //! RTC Control Register Low
    0 => secf,  //= Second Flag
    1 => alrf,  //= Alarm Flag
    2 => owf,  //= Overflow Flag
    3 => rsf,  //= Registers Synchronized               Flag
    4 => cnf,  //= Configuration Flag
    5 => rtoff: ro,  //= RTC operation OFF
  },
  0x08 => reg32 prlh {  //! RTC Prescaler Load Register           High
    3..0 => prlh: wo,  //= RTC Prescaler Load Register               High
  },
  0x0c => reg32 prll {  //! RTC Prescaler Load Register           Low
    15..0 => prll: wo,  //= RTC Prescaler Divider Register               Low
  },
  0x10 => reg32 divh {  //! RTC Prescaler Divider Register           High
    3..0 => divh: ro,  //= RTC prescaler divider register               high
  },
  0x14 => reg32 divl {  //! RTC Prescaler Divider Register           Low
    15..0 => divl: ro,  //= RTC prescaler divider register               Low
  },
  0x18 => reg32 cnth {  //! RTC Counter Register High
    15..0 => cnth,  //= RTC counter register high
  },
  0x1c => reg32 cntl {  //! RTC Counter Register Low
    15..0 => cntl,  //= RTC counter register Low
  },
  0x20 => reg32 alrh {  //! RTC Alarm Register High
    15..0 => alrh: wo,  //= RTC alarm register high
  },
  0x24 => reg32 alrl {  //! RTC Alarm Register Low
    15..0 => alrl: wo,  //= RTC alarm register low
  },
});
ioregs! (BKP @ 0x40006c04 = {  //! Backup registers
  0x00 => reg32 dr1 {  //! Backup data register (BKP_DR)
    15..0 => d1,  //= Backup data
  },
  0x04 => reg32 dr2 {  //! Backup data register (BKP_DR)
    15..0 => d2,  //= Backup data
  },
  0x08 => reg32 dr3 {  //! Backup data register (BKP_DR)
    15..0 => d3,  //= Backup data
  },
  0x0c => reg32 dr4 {  //! Backup data register (BKP_DR)
    15..0 => d4,  //= Backup data
  },
  0x10 => reg32 dr5 {  //! Backup data register (BKP_DR)
    15..0 => d5,  //= Backup data
  },
  0x14 => reg32 dr6 {  //! Backup data register (BKP_DR)
    15..0 => d6,  //= Backup data
  },
  0x18 => reg32 dr7 {  //! Backup data register (BKP_DR)
    15..0 => d7,  //= Backup data
  },
  0x1c => reg32 dr8 {  //! Backup data register (BKP_DR)
    15..0 => d8,  //= Backup data
  },
  0x20 => reg32 dr9 {  //! Backup data register (BKP_DR)
    15..0 => d9,  //= Backup data
  },
  0x24 => reg32 dr10 {  //! Backup data register (BKP_DR)
    15..0 => d10,  //= Backup data
  },
  0x3c => reg32 dr11 {  //! Backup data register (BKP_DR)
    15..0 => dr11,  //= Backup data
  },
  0x40 => reg32 dr12 {  //! Backup data register (BKP_DR)
    15..0 => dr12,  //= Backup data
  },
  0x44 => reg32 dr13 {  //! Backup data register (BKP_DR)
    15..0 => dr13,  //= Backup data
  },
  0x48 => reg32 dr14 {  //! Backup data register (BKP_DR)
    15..0 => d14,  //= Backup data
  },
  0x4c => reg32 dr15 {  //! Backup data register (BKP_DR)
    15..0 => d15,  //= Backup data
  },
  0x50 => reg32 dr16 {  //! Backup data register (BKP_DR)
    15..0 => d16,  //= Backup data
  },
  0x54 => reg32 dr17 {  //! Backup data register (BKP_DR)
    15..0 => d17,  //= Backup data
  },
  0x58 => reg32 dr18 {  //! Backup data register (BKP_DR)
    15..0 => d18,  //= Backup data
  },
  0x5c => reg32 dr19 {  //! Backup data register (BKP_DR)
    15..0 => d19,  //= Backup data
  },
  0x60 => reg32 dr20 {  //! Backup data register (BKP_DR)
    15..0 => d20,  //= Backup data
  },
  0x64 => reg32 dr21 {  //! Backup data register (BKP_DR)
    15..0 => d21,  //= Backup data
  },
  0x68 => reg32 dr22 {  //! Backup data register (BKP_DR)
    15..0 => d22,  //= Backup data
  },
  0x6c => reg32 dr23 {  //! Backup data register (BKP_DR)
    15..0 => d23,  //= Backup data
  },
  0x70 => reg32 dr24 {  //! Backup data register (BKP_DR)
    15..0 => d24,  //= Backup data
  },
  0x74 => reg32 dr25 {  //! Backup data register (BKP_DR)
    15..0 => d25,  //= Backup data
  },
  0x78 => reg32 dr26 {  //! Backup data register (BKP_DR)
    15..0 => d26,  //= Backup data
  },
  0x7c => reg32 dr27 {  //! Backup data register (BKP_DR)
    15..0 => d27,  //= Backup data
  },
  0x80 => reg32 dr28 {  //! Backup data register (BKP_DR)
    15..0 => d28,  //= Backup data
  },
  0x84 => reg32 dr29 {  //! Backup data register (BKP_DR)
    15..0 => d29,  //= Backup data
  },
  0x88 => reg32 dr30 {  //! Backup data register (BKP_DR)
    15..0 => d30,  //= Backup data
  },
  0x8c => reg32 dr31 {  //! Backup data register (BKP_DR)
    15..0 => d31,  //= Backup data
  },
  0x90 => reg32 dr32 {  //! Backup data register (BKP_DR)
    15..0 => d32,  //= Backup data
  },
  0x94 => reg32 dr33 {  //! Backup data register (BKP_DR)
    15..0 => d33,  //= Backup data
  },
  0x98 => reg32 dr34 {  //! Backup data register (BKP_DR)
    15..0 => d34,  //= Backup data
  },
  0x9c => reg32 dr35 {  //! Backup data register (BKP_DR)
    15..0 => d35,  //= Backup data
  },
  0xa0 => reg32 dr36 {  //! Backup data register (BKP_DR)
    15..0 => d36,  //= Backup data
  },
  0xa4 => reg32 dr37 {  //! Backup data register (BKP_DR)
    15..0 => d37,  //= Backup data
  },
  0xa8 => reg32 dr38 {  //! Backup data register (BKP_DR)
    15..0 => d38,  //= Backup data
  },
  0xac => reg32 dr39 {  //! Backup data register (BKP_DR)
    15..0 => d39,  //= Backup data
  },
  0xb0 => reg32 dr40 {  //! Backup data register (BKP_DR)
    15..0 => d40,  //= Backup data
  },
  0xb4 => reg32 dr41 {  //! Backup data register (BKP_DR)
    15..0 => d41,  //= Backup data
  },
  0xb8 => reg32 dr42 {  //! Backup data register (BKP_DR)
    15..0 => d42,  //= Backup data
  },
  0x28 => reg32 rtccr {  //! RTC clock calibration register           (BKP_RTCCR)
    6..0 => cal,  //= Calibration value
    7 => cco,  //= Calibration Clock Output
    8 => asoe,  //= Alarm or second output               enable
    9 => asos,  //= Alarm or second output               selection
  },
  0x2c => reg32 cr {  //! Backup control register           (BKP_CR)
    0 => tpe,  //= Tamper pin enable
    1 => tpal,  //= Tamper pin active level
  },
  0x30 => reg32 csr {  //! BKP_CSR control/status register           (BKP_CSR)
    0 => cte: wo,  //= Clear Tamper event
    1 => cti: wo,  //= Clear Tamper Interrupt
    2 => tpie,  //= Tamper Pin interrupt               enable
    8 => tef: ro,  //= Tamper Event Flag
    9 => tif: ro,  //= Tamper Interrupt Flag
  },
});
ioregs! (IWDG @ 0x40003000 = {  //! Independent watchdog
  0x00 => reg32 kr {  //! Key register (IWDG_KR)
    15..0 => key: wo,  //= Key value
  },
  0x04 => reg32 pr {  //! Prescaler register (IWDG_PR)
    2..0 => pr,  //= Prescaler divider
  },
  0x08 => reg32 rlr {  //! Reload register (IWDG_RLR)
    11..0 => rl,  //= Watchdog counter reload               value
  },
  0x0c => reg32 sr {  //! Status register (IWDG_SR)
    0 => pvu: ro,  //= Watchdog prescaler value               update
    1 => rvu: ro,  //= Watchdog counter reload value               update
  },
});
ioregs! (WWDG @ 0x40002c00 = {  //! Window watchdog
  0x00 => reg32 cr {  //! Control register (WWDG_CR)
    6..0 => t,  //= 7-bit counter (MSB to LSB)
    7 => wdga,  //= Activation bit
  },
  0x04 => reg32 cfr {  //! Configuration register           (WWDG_CFR)
    6..0 => w,  //= 7-bit window value
    8..7 => wdgtb,  //= Timer Base
    9 => ewi,  //= Early Wakeup Interrupt
  },
  0x08 => reg32 sr {  //! Status register (WWDG_SR)
    0 => ewi,  //= Early Wakeup Interrupt
  },
});
ioregs! (TIM1 @ 0x40012c00 = {  //! Advanced timer
  0x00 => reg32 cr1 {  //! control register 1
    9..8 => ckd,  //= Clock division
    7 => arpe,  //= Auto-reload preload enable
    6..5 => cms,  //= Center-aligned mode               selection
    4 => dir,  //= Direction
    3 => opm,  //= One-pulse mode
    2 => urs,  //= Update request source
    1 => udis,  //= Update disable
    0 => cen,  //= Counter enable
  },
  0x04 => reg32 cr2 {  //! control register 2
    14 => ois4,  //= Output Idle state 4
    13 => ois3n,  //= Output Idle state 3
    12 => ois3,  //= Output Idle state 3
    11 => ois2n,  //= Output Idle state 2
    10 => ois2,  //= Output Idle state 2
    9 => ois1n,  //= Output Idle state 1
    8 => ois1,  //= Output Idle state 1
    7 => ti1s,  //= TI1 selection
    6..4 => mms,  //= Master mode selection
    3 => ccds,  //= Capture/compare DMA               selection
    2 => ccus,  //= Capture/compare control update               selection
    0 => ccpc,  //= Capture/compare preloaded               control
  },
  0x08 => reg32 smcr {  //! slave mode control register
    15 => etp,  //= External trigger polarity
    14 => ece,  //= External clock enable
    13..12 => etps,  //= External trigger prescaler
    11..8 => etf,  //= External trigger filter
    7 => msm,  //= Master/Slave mode
    6..4 => ts,  //= Trigger selection
    2..0 => sms,  //= Slave mode selection
  },
  0x0c => reg32 dier {  //! DMA/Interrupt enable register
    14 => tde,  //= Trigger DMA request enable
    13 => comde,  //= COM DMA request enable
    12 => cc4de,  //= Capture/Compare 4 DMA request               enable
    11 => cc3de,  //= Capture/Compare 3 DMA request               enable
    10 => cc2de,  //= Capture/Compare 2 DMA request               enable
    9 => cc1de,  //= Capture/Compare 1 DMA request               enable
    8 => ude,  //= Update DMA request enable
    6 => tie,  //= Trigger interrupt enable
    4 => cc4ie,  //= Capture/Compare 4 interrupt               enable
    3 => cc3ie,  //= Capture/Compare 3 interrupt               enable
    2 => cc2ie,  //= Capture/Compare 2 interrupt               enable
    1 => cc1ie,  //= Capture/Compare 1 interrupt               enable
    0 => uie,  //= Update interrupt enable
    7 => bie,  //= Break interrupt enable
    5 => comie,  //= COM interrupt enable
  },
  0x10 => reg32 sr {  //! status register
    12 => cc4of,  //= Capture/Compare 4 overcapture               flag
    11 => cc3of,  //= Capture/Compare 3 overcapture               flag
    10 => cc2of,  //= Capture/compare 2 overcapture               flag
    9 => cc1of,  //= Capture/Compare 1 overcapture               flag
    7 => bif,  //= Break interrupt flag
    6 => tif,  //= Trigger interrupt flag
    5 => comif,  //= COM interrupt flag
    4 => cc4if,  //= Capture/Compare 4 interrupt               flag
    3 => cc3if,  //= Capture/Compare 3 interrupt               flag
    2 => cc2if,  //= Capture/Compare 2 interrupt               flag
    1 => cc1if,  //= Capture/compare 1 interrupt               flag
    0 => uif,  //= Update interrupt flag
  },
  0x14 => reg32 egr {  //! event generation register
    7 => bg: wo,  //= Break generation
    6 => tg: wo,  //= Trigger generation
    5 => comg: wo,  //= Capture/Compare control update               generation
    4 => cc4g: wo,  //= Capture/compare 4               generation
    3 => cc3g: wo,  //= Capture/compare 3               generation
    2 => cc2g: wo,  //= Capture/compare 2               generation
    1 => cc1g: wo,  //= Capture/compare 1               generation
    0 => ug: wo,  //= Update generation
  },
  0x18 => reg32 ccmr1_output {  //! capture/compare mode register (output           mode)
    15 => oc2ce,  //= Output Compare 2 clear               enable
    14..12 => oc2m,  //= Output Compare 2 mode
    11 => oc2pe,  //= Output Compare 2 preload               enable
    10 => oc2fe,  //= Output Compare 2 fast               enable
    9..8 => cc2s,  //= Capture/Compare 2               selection
    7 => oc1ce,  //= Output Compare 1 clear               enable
    6..4 => oc1m,  //= Output Compare 1 mode
    3 => oc1pe,  //= Output Compare 1 preload               enable
    2 => oc1fe,  //= Output Compare 1 fast               enable
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x18 => reg32 ccmr1_input {  //! capture/compare mode register 1 (input           mode)
    15..12 => ic2f,  //= Input capture 2 filter
    11..10 => ic2pcs,  //= Input capture 2 prescaler
    9..8 => cc2s,  //= Capture/Compare 2               selection
    7..4 => ic1f,  //= Input capture 1 filter
    3..2 => icpcs,  //= Input capture 1 prescaler
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x1c => reg32 ccmr2_output {  //! capture/compare mode register (output           mode)
    15 => oc4ce,  //= Output compare 4 clear               enable
    14..12 => oc4m,  //= Output compare 4 mode
    11 => oc4pe,  //= Output compare 4 preload               enable
    10 => oc4fe,  //= Output compare 4 fast               enable
    9..8 => cc4s,  //= Capture/Compare 4               selection
    7 => oc3ce,  //= Output compare 3 clear               enable
    6..4 => oc3m,  //= Output compare 3 mode
    3 => oc3pe,  //= Output compare 3 preload               enable
    2 => oc3fe,  //= Output compare 3 fast               enable
    1..0 => cc3s,  //= Capture/Compare 3               selection
  },
  0x1c => reg32 ccmr2_input {  //! capture/compare mode register 2 (input           mode)
    15..12 => ic4f,  //= Input capture 4 filter
    11..10 => ic4psc,  //= Input capture 4 prescaler
    9..8 => cc4s,  //= Capture/Compare 4               selection
    7..4 => ic3f,  //= Input capture 3 filter
    3..2 => ic3psc,  //= Input capture 3 prescaler
    1..0 => cc3s,  //= Capture/compare 3               selection
  },
  0x20 => reg32 ccer {  //! capture/compare enable           register
    13 => cc4p,  //= Capture/Compare 3 output               Polarity
    12 => cc4e,  //= Capture/Compare 4 output               enable
    11 => cc3np,  //= Capture/Compare 3 output               Polarity
    10 => cc3ne,  //= Capture/Compare 3 complementary output               enable
    9 => cc3p,  //= Capture/Compare 3 output               Polarity
    8 => cc3e,  //= Capture/Compare 3 output               enable
    7 => cc2np,  //= Capture/Compare 2 output               Polarity
    6 => cc2ne,  //= Capture/Compare 2 complementary output               enable
    5 => cc2p,  //= Capture/Compare 2 output               Polarity
    4 => cc2e,  //= Capture/Compare 2 output               enable
    3 => cc1np,  //= Capture/Compare 1 output               Polarity
    2 => cc1ne,  //= Capture/Compare 1 complementary output               enable
    1 => cc1p,  //= Capture/Compare 1 output               Polarity
    0 => cc1e,  //= Capture/Compare 1 output               enable
  },
  0x24 => reg32 cnt {  //! counter
    15..0 => cnt,  //= counter value
  },
  0x28 => reg32 psc {  //! prescaler
    15..0 => psc,  //= Prescaler value
  },
  0x2c => reg32 arr {  //! auto-reload register
    15..0 => arr,  //= Auto-reload value
  },
  0x34 => reg32 ccr1 {  //! capture/compare register 1
    15..0 => ccr1,  //= Capture/Compare 1 value
  },
  0x38 => reg32 ccr2 {  //! capture/compare register 2
    15..0 => ccr2,  //= Capture/Compare 2 value
  },
  0x3c => reg32 ccr3 {  //! capture/compare register 3
    15..0 => ccr3,  //= Capture/Compare value
  },
  0x40 => reg32 ccr4 {  //! capture/compare register 4
    15..0 => ccr4,  //= Capture/Compare value
  },
  0x48 => reg32 dcr {  //! DMA control register
    12..8 => dbl,  //= DMA burst length
    4..0 => dba,  //= DMA base address
  },
  0x4c => reg32 dmar {  //! DMA address for full transfer
    15..0 => dmab,  //= DMA register for burst               accesses
  },
  0x30 => reg32 rcr {  //! repetition counter register
    7..0 => rep,  //= Repetition counter value
  },
  0x44 => reg32 bdtr {  //! break and dead-time register
    15 => moe,  //= Main output enable
    14 => aoe,  //= Automatic output enable
    13 => bkp,  //= Break polarity
    12 => bke,  //= Break enable
    11 => ossr,  //= Off-state selection for Run               mode
    10 => ossi,  //= Off-state selection for Idle               mode
    9..8 => lock,  //= Lock configuration
    7..0 => dtg,  //= Dead-time generator setup
  },
});
ioregs! (TIM8 @ 0x40013400 = {  //! Advanced timer
  0x00 => reg32 cr1 {  //! control register 1
    9..8 => ckd,  //= Clock division
    7 => arpe,  //= Auto-reload preload enable
    6..5 => cms,  //= Center-aligned mode               selection
    4 => dir,  //= Direction
    3 => opm,  //= One-pulse mode
    2 => urs,  //= Update request source
    1 => udis,  //= Update disable
    0 => cen,  //= Counter enable
  },
  0x04 => reg32 cr2 {  //! control register 2
    14 => ois4,  //= Output Idle state 4
    13 => ois3n,  //= Output Idle state 3
    12 => ois3,  //= Output Idle state 3
    11 => ois2n,  //= Output Idle state 2
    10 => ois2,  //= Output Idle state 2
    9 => ois1n,  //= Output Idle state 1
    8 => ois1,  //= Output Idle state 1
    7 => ti1s,  //= TI1 selection
    6..4 => mms,  //= Master mode selection
    3 => ccds,  //= Capture/compare DMA               selection
    2 => ccus,  //= Capture/compare control update               selection
    0 => ccpc,  //= Capture/compare preloaded               control
  },
  0x08 => reg32 smcr {  //! slave mode control register
    15 => etp,  //= External trigger polarity
    14 => ece,  //= External clock enable
    13..12 => etps,  //= External trigger prescaler
    11..8 => etf,  //= External trigger filter
    7 => msm,  //= Master/Slave mode
    6..4 => ts,  //= Trigger selection
    2..0 => sms,  //= Slave mode selection
  },
  0x0c => reg32 dier {  //! DMA/Interrupt enable register
    14 => tde,  //= Trigger DMA request enable
    13 => comde,  //= COM DMA request enable
    12 => cc4de,  //= Capture/Compare 4 DMA request               enable
    11 => cc3de,  //= Capture/Compare 3 DMA request               enable
    10 => cc2de,  //= Capture/Compare 2 DMA request               enable
    9 => cc1de,  //= Capture/Compare 1 DMA request               enable
    8 => ude,  //= Update DMA request enable
    6 => tie,  //= Trigger interrupt enable
    4 => cc4ie,  //= Capture/Compare 4 interrupt               enable
    3 => cc3ie,  //= Capture/Compare 3 interrupt               enable
    2 => cc2ie,  //= Capture/Compare 2 interrupt               enable
    1 => cc1ie,  //= Capture/Compare 1 interrupt               enable
    0 => uie,  //= Update interrupt enable
    7 => bie,  //= Break interrupt enable
    5 => comie,  //= COM interrupt enable
  },
  0x10 => reg32 sr {  //! status register
    12 => cc4of,  //= Capture/Compare 4 overcapture               flag
    11 => cc3of,  //= Capture/Compare 3 overcapture               flag
    10 => cc2of,  //= Capture/compare 2 overcapture               flag
    9 => cc1of,  //= Capture/Compare 1 overcapture               flag
    7 => bif,  //= Break interrupt flag
    6 => tif,  //= Trigger interrupt flag
    5 => comif,  //= COM interrupt flag
    4 => cc4if,  //= Capture/Compare 4 interrupt               flag
    3 => cc3if,  //= Capture/Compare 3 interrupt               flag
    2 => cc2if,  //= Capture/Compare 2 interrupt               flag
    1 => cc1if,  //= Capture/compare 1 interrupt               flag
    0 => uif,  //= Update interrupt flag
  },
  0x14 => reg32 egr {  //! event generation register
    7 => bg: wo,  //= Break generation
    6 => tg: wo,  //= Trigger generation
    5 => comg: wo,  //= Capture/Compare control update               generation
    4 => cc4g: wo,  //= Capture/compare 4               generation
    3 => cc3g: wo,  //= Capture/compare 3               generation
    2 => cc2g: wo,  //= Capture/compare 2               generation
    1 => cc1g: wo,  //= Capture/compare 1               generation
    0 => ug: wo,  //= Update generation
  },
  0x18 => reg32 ccmr1_output {  //! capture/compare mode register (output           mode)
    15 => oc2ce,  //= Output Compare 2 clear               enable
    14..12 => oc2m,  //= Output Compare 2 mode
    11 => oc2pe,  //= Output Compare 2 preload               enable
    10 => oc2fe,  //= Output Compare 2 fast               enable
    9..8 => cc2s,  //= Capture/Compare 2               selection
    7 => oc1ce,  //= Output Compare 1 clear               enable
    6..4 => oc1m,  //= Output Compare 1 mode
    3 => oc1pe,  //= Output Compare 1 preload               enable
    2 => oc1fe,  //= Output Compare 1 fast               enable
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x18 => reg32 ccmr1_input {  //! capture/compare mode register 1 (input           mode)
    15..12 => ic2f,  //= Input capture 2 filter
    11..10 => ic2pcs,  //= Input capture 2 prescaler
    9..8 => cc2s,  //= Capture/Compare 2               selection
    7..4 => ic1f,  //= Input capture 1 filter
    3..2 => icpcs,  //= Input capture 1 prescaler
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x1c => reg32 ccmr2_output {  //! capture/compare mode register (output           mode)
    15 => oc4ce,  //= Output compare 4 clear               enable
    14..12 => oc4m,  //= Output compare 4 mode
    11 => oc4pe,  //= Output compare 4 preload               enable
    10 => oc4fe,  //= Output compare 4 fast               enable
    9..8 => cc4s,  //= Capture/Compare 4               selection
    7 => oc3ce,  //= Output compare 3 clear               enable
    6..4 => oc3m,  //= Output compare 3 mode
    3 => oc3pe,  //= Output compare 3 preload               enable
    2 => oc3fe,  //= Output compare 3 fast               enable
    1..0 => cc3s,  //= Capture/Compare 3               selection
  },
  0x1c => reg32 ccmr2_input {  //! capture/compare mode register 2 (input           mode)
    15..12 => ic4f,  //= Input capture 4 filter
    11..10 => ic4psc,  //= Input capture 4 prescaler
    9..8 => cc4s,  //= Capture/Compare 4               selection
    7..4 => ic3f,  //= Input capture 3 filter
    3..2 => ic3psc,  //= Input capture 3 prescaler
    1..0 => cc3s,  //= Capture/compare 3               selection
  },
  0x20 => reg32 ccer {  //! capture/compare enable           register
    13 => cc4p,  //= Capture/Compare 3 output               Polarity
    12 => cc4e,  //= Capture/Compare 4 output               enable
    11 => cc3np,  //= Capture/Compare 3 output               Polarity
    10 => cc3ne,  //= Capture/Compare 3 complementary output               enable
    9 => cc3p,  //= Capture/Compare 3 output               Polarity
    8 => cc3e,  //= Capture/Compare 3 output               enable
    7 => cc2np,  //= Capture/Compare 2 output               Polarity
    6 => cc2ne,  //= Capture/Compare 2 complementary output               enable
    5 => cc2p,  //= Capture/Compare 2 output               Polarity
    4 => cc2e,  //= Capture/Compare 2 output               enable
    3 => cc1np,  //= Capture/Compare 1 output               Polarity
    2 => cc1ne,  //= Capture/Compare 1 complementary output               enable
    1 => cc1p,  //= Capture/Compare 1 output               Polarity
    0 => cc1e,  //= Capture/Compare 1 output               enable
  },
  0x24 => reg32 cnt {  //! counter
    15..0 => cnt,  //= counter value
  },
  0x28 => reg32 psc {  //! prescaler
    15..0 => psc,  //= Prescaler value
  },
  0x2c => reg32 arr {  //! auto-reload register
    15..0 => arr,  //= Auto-reload value
  },
  0x34 => reg32 ccr1 {  //! capture/compare register 1
    15..0 => ccr1,  //= Capture/Compare 1 value
  },
  0x38 => reg32 ccr2 {  //! capture/compare register 2
    15..0 => ccr2,  //= Capture/Compare 2 value
  },
  0x3c => reg32 ccr3 {  //! capture/compare register 3
    15..0 => ccr3,  //= Capture/Compare value
  },
  0x40 => reg32 ccr4 {  //! capture/compare register 4
    15..0 => ccr4,  //= Capture/Compare value
  },
  0x48 => reg32 dcr {  //! DMA control register
    12..8 => dbl,  //= DMA burst length
    4..0 => dba,  //= DMA base address
  },
  0x4c => reg32 dmar {  //! DMA address for full transfer
    15..0 => dmab,  //= DMA register for burst               accesses
  },
  0x30 => reg32 rcr {  //! repetition counter register
    7..0 => rep,  //= Repetition counter value
  },
  0x44 => reg32 bdtr {  //! break and dead-time register
    15 => moe,  //= Main output enable
    14 => aoe,  //= Automatic output enable
    13 => bkp,  //= Break polarity
    12 => bke,  //= Break enable
    11 => ossr,  //= Off-state selection for Run               mode
    10 => ossi,  //= Off-state selection for Idle               mode
    9..8 => lock,  //= Lock configuration
    7..0 => dtg,  //= Dead-time generator setup
  },
});
ioregs! (TIM2 @ 0x40000000 = {  //! General purpose timer
  0x00 => reg32 cr1 {  //! control register 1
    9..8 => ckd,  //= Clock division
    7 => arpe,  //= Auto-reload preload enable
    6..5 => cms,  //= Center-aligned mode               selection
    4 => dir,  //= Direction
    3 => opm,  //= One-pulse mode
    2 => urs,  //= Update request source
    1 => udis,  //= Update disable
    0 => cen,  //= Counter enable
  },
  0x04 => reg32 cr2 {  //! control register 2
    7 => ti1s,  //= TI1 selection
    6..4 => mms,  //= Master mode selection
    3 => ccds,  //= Capture/compare DMA               selection
  },
  0x08 => reg32 smcr {  //! slave mode control register
    15 => etp,  //= External trigger polarity
    14 => ece,  //= External clock enable
    13..12 => etps,  //= External trigger prescaler
    11..8 => etf,  //= External trigger filter
    7 => msm,  //= Master/Slave mode
    6..4 => ts,  //= Trigger selection
    2..0 => sms,  //= Slave mode selection
  },
  0x0c => reg32 dier {  //! DMA/Interrupt enable register
    14 => tde,  //= Trigger DMA request enable
    12 => cc4de,  //= Capture/Compare 4 DMA request               enable
    11 => cc3de,  //= Capture/Compare 3 DMA request               enable
    10 => cc2de,  //= Capture/Compare 2 DMA request               enable
    9 => cc1de,  //= Capture/Compare 1 DMA request               enable
    8 => ude,  //= Update DMA request enable
    6 => tie,  //= Trigger interrupt enable
    4 => cc4ie,  //= Capture/Compare 4 interrupt               enable
    3 => cc3ie,  //= Capture/Compare 3 interrupt               enable
    2 => cc2ie,  //= Capture/Compare 2 interrupt               enable
    1 => cc1ie,  //= Capture/Compare 1 interrupt               enable
    0 => uie,  //= Update interrupt enable
  },
  0x10 => reg32 sr {  //! status register
    12 => cc4of,  //= Capture/Compare 4 overcapture               flag
    11 => cc3of,  //= Capture/Compare 3 overcapture               flag
    10 => cc2of,  //= Capture/compare 2 overcapture               flag
    9 => cc1of,  //= Capture/Compare 1 overcapture               flag
    6 => tif,  //= Trigger interrupt flag
    4 => cc4if,  //= Capture/Compare 4 interrupt               flag
    3 => cc3if,  //= Capture/Compare 3 interrupt               flag
    2 => cc2if,  //= Capture/Compare 2 interrupt               flag
    1 => cc1if,  //= Capture/compare 1 interrupt               flag
    0 => uif,  //= Update interrupt flag
  },
  0x14 => reg32 egr {  //! event generation register
    6 => tg: wo,  //= Trigger generation
    4 => cc4g: wo,  //= Capture/compare 4               generation
    3 => cc3g: wo,  //= Capture/compare 3               generation
    2 => cc2g: wo,  //= Capture/compare 2               generation
    1 => cc1g: wo,  //= Capture/compare 1               generation
    0 => ug: wo,  //= Update generation
  },
  0x18 => reg32 ccmr1_output {  //! capture/compare mode register 1 (output           mode)
    15 => oc2ce,  //= Output compare 2 clear               enable
    14..12 => oc2m,  //= Output compare 2 mode
    11 => oc2pe,  //= Output compare 2 preload               enable
    10 => oc2fe,  //= Output compare 2 fast               enable
    9..8 => cc2s,  //= Capture/Compare 2               selection
    7 => oc1ce,  //= Output compare 1 clear               enable
    6..4 => oc1m,  //= Output compare 1 mode
    3 => oc1pe,  //= Output compare 1 preload               enable
    2 => oc1fe,  //= Output compare 1 fast               enable
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x18 => reg32 ccmr1_input {  //! capture/compare mode register 1 (input           mode)
    15..12 => ic2f,  //= Input capture 2 filter
    11..10 => ic2psc,  //= Input capture 2 prescaler
    9..8 => cc2s,  //= Capture/compare 2               selection
    7..4 => ic1f,  //= Input capture 1 filter
    3..2 => ic1psc,  //= Input capture 1 prescaler
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x1c => reg32 ccmr2_output {  //! capture/compare mode register 2 (output           mode)
    15 => o24ce,  //= Output compare 4 clear               enable
    14..12 => oc4m,  //= Output compare 4 mode
    11 => oc4pe,  //= Output compare 4 preload               enable
    10 => oc4fe,  //= Output compare 4 fast               enable
    9..8 => cc4s,  //= Capture/Compare 4               selection
    7 => oc3ce,  //= Output compare 3 clear               enable
    6..4 => oc3m,  //= Output compare 3 mode
    3 => oc3pe,  //= Output compare 3 preload               enable
    2 => oc3fe,  //= Output compare 3 fast               enable
    1..0 => cc3s,  //= Capture/Compare 3               selection
  },
  0x1c => reg32 ccmr2_input {  //! capture/compare mode register 2 (input           mode)
    15..12 => ic4f,  //= Input capture 4 filter
    11..10 => ic4psc,  //= Input capture 4 prescaler
    9..8 => cc4s,  //= Capture/Compare 4               selection
    7..4 => ic3f,  //= Input capture 3 filter
    3..2 => ic3psc,  //= Input capture 3 prescaler
    1..0 => cc3s,  //= Capture/Compare 3               selection
  },
  0x20 => reg32 ccer {  //! capture/compare enable           register
    13 => cc4p,  //= Capture/Compare 3 output               Polarity
    12 => cc4e,  //= Capture/Compare 4 output               enable
    9 => cc3p,  //= Capture/Compare 3 output               Polarity
    8 => cc3e,  //= Capture/Compare 3 output               enable
    5 => cc2p,  //= Capture/Compare 2 output               Polarity
    4 => cc2e,  //= Capture/Compare 2 output               enable
    1 => cc1p,  //= Capture/Compare 1 output               Polarity
    0 => cc1e,  //= Capture/Compare 1 output               enable
  },
  0x24 => reg32 cnt {  //! counter
    15..0 => cnt,  //= counter value
  },
  0x28 => reg32 psc {  //! prescaler
    15..0 => psc,  //= Prescaler value
  },
  0x2c => reg32 arr {  //! auto-reload register
    15..0 => arr,  //= Auto-reload value
  },
  0x34 => reg32 ccr1 {  //! capture/compare register 1
    15..0 => ccr1,  //= Capture/Compare 1 value
  },
  0x38 => reg32 ccr2 {  //! capture/compare register 2
    15..0 => ccr2,  //= Capture/Compare 2 value
  },
  0x3c => reg32 ccr3 {  //! capture/compare register 3
    15..0 => ccr3,  //= Capture/Compare value
  },
  0x40 => reg32 ccr4 {  //! capture/compare register 4
    15..0 => ccr4,  //= Capture/Compare value
  },
  0x48 => reg32 dcr {  //! DMA control register
    12..8 => dbl,  //= DMA burst length
    4..0 => dba,  //= DMA base address
  },
  0x4c => reg32 dmar {  //! DMA address for full transfer
    15..0 => dmab,  //= DMA register for burst               accesses
  },
});
ioregs! (TIM3 @ 0x40000400 = {  //! General purpose timer
  0x00 => reg32 cr1 {  //! control register 1
    9..8 => ckd,  //= Clock division
    7 => arpe,  //= Auto-reload preload enable
    6..5 => cms,  //= Center-aligned mode               selection
    4 => dir,  //= Direction
    3 => opm,  //= One-pulse mode
    2 => urs,  //= Update request source
    1 => udis,  //= Update disable
    0 => cen,  //= Counter enable
  },
  0x04 => reg32 cr2 {  //! control register 2
    7 => ti1s,  //= TI1 selection
    6..4 => mms,  //= Master mode selection
    3 => ccds,  //= Capture/compare DMA               selection
  },
  0x08 => reg32 smcr {  //! slave mode control register
    15 => etp,  //= External trigger polarity
    14 => ece,  //= External clock enable
    13..12 => etps,  //= External trigger prescaler
    11..8 => etf,  //= External trigger filter
    7 => msm,  //= Master/Slave mode
    6..4 => ts,  //= Trigger selection
    2..0 => sms,  //= Slave mode selection
  },
  0x0c => reg32 dier {  //! DMA/Interrupt enable register
    14 => tde,  //= Trigger DMA request enable
    12 => cc4de,  //= Capture/Compare 4 DMA request               enable
    11 => cc3de,  //= Capture/Compare 3 DMA request               enable
    10 => cc2de,  //= Capture/Compare 2 DMA request               enable
    9 => cc1de,  //= Capture/Compare 1 DMA request               enable
    8 => ude,  //= Update DMA request enable
    6 => tie,  //= Trigger interrupt enable
    4 => cc4ie,  //= Capture/Compare 4 interrupt               enable
    3 => cc3ie,  //= Capture/Compare 3 interrupt               enable
    2 => cc2ie,  //= Capture/Compare 2 interrupt               enable
    1 => cc1ie,  //= Capture/Compare 1 interrupt               enable
    0 => uie,  //= Update interrupt enable
  },
  0x10 => reg32 sr {  //! status register
    12 => cc4of,  //= Capture/Compare 4 overcapture               flag
    11 => cc3of,  //= Capture/Compare 3 overcapture               flag
    10 => cc2of,  //= Capture/compare 2 overcapture               flag
    9 => cc1of,  //= Capture/Compare 1 overcapture               flag
    6 => tif,  //= Trigger interrupt flag
    4 => cc4if,  //= Capture/Compare 4 interrupt               flag
    3 => cc3if,  //= Capture/Compare 3 interrupt               flag
    2 => cc2if,  //= Capture/Compare 2 interrupt               flag
    1 => cc1if,  //= Capture/compare 1 interrupt               flag
    0 => uif,  //= Update interrupt flag
  },
  0x14 => reg32 egr {  //! event generation register
    6 => tg: wo,  //= Trigger generation
    4 => cc4g: wo,  //= Capture/compare 4               generation
    3 => cc3g: wo,  //= Capture/compare 3               generation
    2 => cc2g: wo,  //= Capture/compare 2               generation
    1 => cc1g: wo,  //= Capture/compare 1               generation
    0 => ug: wo,  //= Update generation
  },
  0x18 => reg32 ccmr1_output {  //! capture/compare mode register 1 (output           mode)
    15 => oc2ce,  //= Output compare 2 clear               enable
    14..12 => oc2m,  //= Output compare 2 mode
    11 => oc2pe,  //= Output compare 2 preload               enable
    10 => oc2fe,  //= Output compare 2 fast               enable
    9..8 => cc2s,  //= Capture/Compare 2               selection
    7 => oc1ce,  //= Output compare 1 clear               enable
    6..4 => oc1m,  //= Output compare 1 mode
    3 => oc1pe,  //= Output compare 1 preload               enable
    2 => oc1fe,  //= Output compare 1 fast               enable
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x18 => reg32 ccmr1_input {  //! capture/compare mode register 1 (input           mode)
    15..12 => ic2f,  //= Input capture 2 filter
    11..10 => ic2psc,  //= Input capture 2 prescaler
    9..8 => cc2s,  //= Capture/compare 2               selection
    7..4 => ic1f,  //= Input capture 1 filter
    3..2 => ic1psc,  //= Input capture 1 prescaler
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x1c => reg32 ccmr2_output {  //! capture/compare mode register 2 (output           mode)
    15 => o24ce,  //= Output compare 4 clear               enable
    14..12 => oc4m,  //= Output compare 4 mode
    11 => oc4pe,  //= Output compare 4 preload               enable
    10 => oc4fe,  //= Output compare 4 fast               enable
    9..8 => cc4s,  //= Capture/Compare 4               selection
    7 => oc3ce,  //= Output compare 3 clear               enable
    6..4 => oc3m,  //= Output compare 3 mode
    3 => oc3pe,  //= Output compare 3 preload               enable
    2 => oc3fe,  //= Output compare 3 fast               enable
    1..0 => cc3s,  //= Capture/Compare 3               selection
  },
  0x1c => reg32 ccmr2_input {  //! capture/compare mode register 2 (input           mode)
    15..12 => ic4f,  //= Input capture 4 filter
    11..10 => ic4psc,  //= Input capture 4 prescaler
    9..8 => cc4s,  //= Capture/Compare 4               selection
    7..4 => ic3f,  //= Input capture 3 filter
    3..2 => ic3psc,  //= Input capture 3 prescaler
    1..0 => cc3s,  //= Capture/Compare 3               selection
  },
  0x20 => reg32 ccer {  //! capture/compare enable           register
    13 => cc4p,  //= Capture/Compare 3 output               Polarity
    12 => cc4e,  //= Capture/Compare 4 output               enable
    9 => cc3p,  //= Capture/Compare 3 output               Polarity
    8 => cc3e,  //= Capture/Compare 3 output               enable
    5 => cc2p,  //= Capture/Compare 2 output               Polarity
    4 => cc2e,  //= Capture/Compare 2 output               enable
    1 => cc1p,  //= Capture/Compare 1 output               Polarity
    0 => cc1e,  //= Capture/Compare 1 output               enable
  },
  0x24 => reg32 cnt {  //! counter
    15..0 => cnt,  //= counter value
  },
  0x28 => reg32 psc {  //! prescaler
    15..0 => psc,  //= Prescaler value
  },
  0x2c => reg32 arr {  //! auto-reload register
    15..0 => arr,  //= Auto-reload value
  },
  0x34 => reg32 ccr1 {  //! capture/compare register 1
    15..0 => ccr1,  //= Capture/Compare 1 value
  },
  0x38 => reg32 ccr2 {  //! capture/compare register 2
    15..0 => ccr2,  //= Capture/Compare 2 value
  },
  0x3c => reg32 ccr3 {  //! capture/compare register 3
    15..0 => ccr3,  //= Capture/Compare value
  },
  0x40 => reg32 ccr4 {  //! capture/compare register 4
    15..0 => ccr4,  //= Capture/Compare value
  },
  0x48 => reg32 dcr {  //! DMA control register
    12..8 => dbl,  //= DMA burst length
    4..0 => dba,  //= DMA base address
  },
  0x4c => reg32 dmar {  //! DMA address for full transfer
    15..0 => dmab,  //= DMA register for burst               accesses
  },
});
ioregs! (TIM4 @ 0x40000800 = {  //! General purpose timer
  0x00 => reg32 cr1 {  //! control register 1
    9..8 => ckd,  //= Clock division
    7 => arpe,  //= Auto-reload preload enable
    6..5 => cms,  //= Center-aligned mode               selection
    4 => dir,  //= Direction
    3 => opm,  //= One-pulse mode
    2 => urs,  //= Update request source
    1 => udis,  //= Update disable
    0 => cen,  //= Counter enable
  },
  0x04 => reg32 cr2 {  //! control register 2
    7 => ti1s,  //= TI1 selection
    6..4 => mms,  //= Master mode selection
    3 => ccds,  //= Capture/compare DMA               selection
  },
  0x08 => reg32 smcr {  //! slave mode control register
    15 => etp,  //= External trigger polarity
    14 => ece,  //= External clock enable
    13..12 => etps,  //= External trigger prescaler
    11..8 => etf,  //= External trigger filter
    7 => msm,  //= Master/Slave mode
    6..4 => ts,  //= Trigger selection
    2..0 => sms,  //= Slave mode selection
  },
  0x0c => reg32 dier {  //! DMA/Interrupt enable register
    14 => tde,  //= Trigger DMA request enable
    12 => cc4de,  //= Capture/Compare 4 DMA request               enable
    11 => cc3de,  //= Capture/Compare 3 DMA request               enable
    10 => cc2de,  //= Capture/Compare 2 DMA request               enable
    9 => cc1de,  //= Capture/Compare 1 DMA request               enable
    8 => ude,  //= Update DMA request enable
    6 => tie,  //= Trigger interrupt enable
    4 => cc4ie,  //= Capture/Compare 4 interrupt               enable
    3 => cc3ie,  //= Capture/Compare 3 interrupt               enable
    2 => cc2ie,  //= Capture/Compare 2 interrupt               enable
    1 => cc1ie,  //= Capture/Compare 1 interrupt               enable
    0 => uie,  //= Update interrupt enable
  },
  0x10 => reg32 sr {  //! status register
    12 => cc4of,  //= Capture/Compare 4 overcapture               flag
    11 => cc3of,  //= Capture/Compare 3 overcapture               flag
    10 => cc2of,  //= Capture/compare 2 overcapture               flag
    9 => cc1of,  //= Capture/Compare 1 overcapture               flag
    6 => tif,  //= Trigger interrupt flag
    4 => cc4if,  //= Capture/Compare 4 interrupt               flag
    3 => cc3if,  //= Capture/Compare 3 interrupt               flag
    2 => cc2if,  //= Capture/Compare 2 interrupt               flag
    1 => cc1if,  //= Capture/compare 1 interrupt               flag
    0 => uif,  //= Update interrupt flag
  },
  0x14 => reg32 egr {  //! event generation register
    6 => tg: wo,  //= Trigger generation
    4 => cc4g: wo,  //= Capture/compare 4               generation
    3 => cc3g: wo,  //= Capture/compare 3               generation
    2 => cc2g: wo,  //= Capture/compare 2               generation
    1 => cc1g: wo,  //= Capture/compare 1               generation
    0 => ug: wo,  //= Update generation
  },
  0x18 => reg32 ccmr1_output {  //! capture/compare mode register 1 (output           mode)
    15 => oc2ce,  //= Output compare 2 clear               enable
    14..12 => oc2m,  //= Output compare 2 mode
    11 => oc2pe,  //= Output compare 2 preload               enable
    10 => oc2fe,  //= Output compare 2 fast               enable
    9..8 => cc2s,  //= Capture/Compare 2               selection
    7 => oc1ce,  //= Output compare 1 clear               enable
    6..4 => oc1m,  //= Output compare 1 mode
    3 => oc1pe,  //= Output compare 1 preload               enable
    2 => oc1fe,  //= Output compare 1 fast               enable
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x18 => reg32 ccmr1_input {  //! capture/compare mode register 1 (input           mode)
    15..12 => ic2f,  //= Input capture 2 filter
    11..10 => ic2psc,  //= Input capture 2 prescaler
    9..8 => cc2s,  //= Capture/compare 2               selection
    7..4 => ic1f,  //= Input capture 1 filter
    3..2 => ic1psc,  //= Input capture 1 prescaler
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x1c => reg32 ccmr2_output {  //! capture/compare mode register 2 (output           mode)
    15 => o24ce,  //= Output compare 4 clear               enable
    14..12 => oc4m,  //= Output compare 4 mode
    11 => oc4pe,  //= Output compare 4 preload               enable
    10 => oc4fe,  //= Output compare 4 fast               enable
    9..8 => cc4s,  //= Capture/Compare 4               selection
    7 => oc3ce,  //= Output compare 3 clear               enable
    6..4 => oc3m,  //= Output compare 3 mode
    3 => oc3pe,  //= Output compare 3 preload               enable
    2 => oc3fe,  //= Output compare 3 fast               enable
    1..0 => cc3s,  //= Capture/Compare 3               selection
  },
  0x1c => reg32 ccmr2_input {  //! capture/compare mode register 2 (input           mode)
    15..12 => ic4f,  //= Input capture 4 filter
    11..10 => ic4psc,  //= Input capture 4 prescaler
    9..8 => cc4s,  //= Capture/Compare 4               selection
    7..4 => ic3f,  //= Input capture 3 filter
    3..2 => ic3psc,  //= Input capture 3 prescaler
    1..0 => cc3s,  //= Capture/Compare 3               selection
  },
  0x20 => reg32 ccer {  //! capture/compare enable           register
    13 => cc4p,  //= Capture/Compare 3 output               Polarity
    12 => cc4e,  //= Capture/Compare 4 output               enable
    9 => cc3p,  //= Capture/Compare 3 output               Polarity
    8 => cc3e,  //= Capture/Compare 3 output               enable
    5 => cc2p,  //= Capture/Compare 2 output               Polarity
    4 => cc2e,  //= Capture/Compare 2 output               enable
    1 => cc1p,  //= Capture/Compare 1 output               Polarity
    0 => cc1e,  //= Capture/Compare 1 output               enable
  },
  0x24 => reg32 cnt {  //! counter
    15..0 => cnt,  //= counter value
  },
  0x28 => reg32 psc {  //! prescaler
    15..0 => psc,  //= Prescaler value
  },
  0x2c => reg32 arr {  //! auto-reload register
    15..0 => arr,  //= Auto-reload value
  },
  0x34 => reg32 ccr1 {  //! capture/compare register 1
    15..0 => ccr1,  //= Capture/Compare 1 value
  },
  0x38 => reg32 ccr2 {  //! capture/compare register 2
    15..0 => ccr2,  //= Capture/Compare 2 value
  },
  0x3c => reg32 ccr3 {  //! capture/compare register 3
    15..0 => ccr3,  //= Capture/Compare value
  },
  0x40 => reg32 ccr4 {  //! capture/compare register 4
    15..0 => ccr4,  //= Capture/Compare value
  },
  0x48 => reg32 dcr {  //! DMA control register
    12..8 => dbl,  //= DMA burst length
    4..0 => dba,  //= DMA base address
  },
  0x4c => reg32 dmar {  //! DMA address for full transfer
    15..0 => dmab,  //= DMA register for burst               accesses
  },
});
ioregs! (TIM5 @ 0x40000c00 = {  //! General purpose timer
  0x00 => reg32 cr1 {  //! control register 1
    9..8 => ckd,  //= Clock division
    7 => arpe,  //= Auto-reload preload enable
    6..5 => cms,  //= Center-aligned mode               selection
    4 => dir,  //= Direction
    3 => opm,  //= One-pulse mode
    2 => urs,  //= Update request source
    1 => udis,  //= Update disable
    0 => cen,  //= Counter enable
  },
  0x04 => reg32 cr2 {  //! control register 2
    7 => ti1s,  //= TI1 selection
    6..4 => mms,  //= Master mode selection
    3 => ccds,  //= Capture/compare DMA               selection
  },
  0x08 => reg32 smcr {  //! slave mode control register
    15 => etp,  //= External trigger polarity
    14 => ece,  //= External clock enable
    13..12 => etps,  //= External trigger prescaler
    11..8 => etf,  //= External trigger filter
    7 => msm,  //= Master/Slave mode
    6..4 => ts,  //= Trigger selection
    2..0 => sms,  //= Slave mode selection
  },
  0x0c => reg32 dier {  //! DMA/Interrupt enable register
    14 => tde,  //= Trigger DMA request enable
    12 => cc4de,  //= Capture/Compare 4 DMA request               enable
    11 => cc3de,  //= Capture/Compare 3 DMA request               enable
    10 => cc2de,  //= Capture/Compare 2 DMA request               enable
    9 => cc1de,  //= Capture/Compare 1 DMA request               enable
    8 => ude,  //= Update DMA request enable
    6 => tie,  //= Trigger interrupt enable
    4 => cc4ie,  //= Capture/Compare 4 interrupt               enable
    3 => cc3ie,  //= Capture/Compare 3 interrupt               enable
    2 => cc2ie,  //= Capture/Compare 2 interrupt               enable
    1 => cc1ie,  //= Capture/Compare 1 interrupt               enable
    0 => uie,  //= Update interrupt enable
  },
  0x10 => reg32 sr {  //! status register
    12 => cc4of,  //= Capture/Compare 4 overcapture               flag
    11 => cc3of,  //= Capture/Compare 3 overcapture               flag
    10 => cc2of,  //= Capture/compare 2 overcapture               flag
    9 => cc1of,  //= Capture/Compare 1 overcapture               flag
    6 => tif,  //= Trigger interrupt flag
    4 => cc4if,  //= Capture/Compare 4 interrupt               flag
    3 => cc3if,  //= Capture/Compare 3 interrupt               flag
    2 => cc2if,  //= Capture/Compare 2 interrupt               flag
    1 => cc1if,  //= Capture/compare 1 interrupt               flag
    0 => uif,  //= Update interrupt flag
  },
  0x14 => reg32 egr {  //! event generation register
    6 => tg: wo,  //= Trigger generation
    4 => cc4g: wo,  //= Capture/compare 4               generation
    3 => cc3g: wo,  //= Capture/compare 3               generation
    2 => cc2g: wo,  //= Capture/compare 2               generation
    1 => cc1g: wo,  //= Capture/compare 1               generation
    0 => ug: wo,  //= Update generation
  },
  0x18 => reg32 ccmr1_output {  //! capture/compare mode register 1 (output           mode)
    15 => oc2ce,  //= Output compare 2 clear               enable
    14..12 => oc2m,  //= Output compare 2 mode
    11 => oc2pe,  //= Output compare 2 preload               enable
    10 => oc2fe,  //= Output compare 2 fast               enable
    9..8 => cc2s,  //= Capture/Compare 2               selection
    7 => oc1ce,  //= Output compare 1 clear               enable
    6..4 => oc1m,  //= Output compare 1 mode
    3 => oc1pe,  //= Output compare 1 preload               enable
    2 => oc1fe,  //= Output compare 1 fast               enable
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x18 => reg32 ccmr1_input {  //! capture/compare mode register 1 (input           mode)
    15..12 => ic2f,  //= Input capture 2 filter
    11..10 => ic2psc,  //= Input capture 2 prescaler
    9..8 => cc2s,  //= Capture/compare 2               selection
    7..4 => ic1f,  //= Input capture 1 filter
    3..2 => ic1psc,  //= Input capture 1 prescaler
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x1c => reg32 ccmr2_output {  //! capture/compare mode register 2 (output           mode)
    15 => o24ce,  //= Output compare 4 clear               enable
    14..12 => oc4m,  //= Output compare 4 mode
    11 => oc4pe,  //= Output compare 4 preload               enable
    10 => oc4fe,  //= Output compare 4 fast               enable
    9..8 => cc4s,  //= Capture/Compare 4               selection
    7 => oc3ce,  //= Output compare 3 clear               enable
    6..4 => oc3m,  //= Output compare 3 mode
    3 => oc3pe,  //= Output compare 3 preload               enable
    2 => oc3fe,  //= Output compare 3 fast               enable
    1..0 => cc3s,  //= Capture/Compare 3               selection
  },
  0x1c => reg32 ccmr2_input {  //! capture/compare mode register 2 (input           mode)
    15..12 => ic4f,  //= Input capture 4 filter
    11..10 => ic4psc,  //= Input capture 4 prescaler
    9..8 => cc4s,  //= Capture/Compare 4               selection
    7..4 => ic3f,  //= Input capture 3 filter
    3..2 => ic3psc,  //= Input capture 3 prescaler
    1..0 => cc3s,  //= Capture/Compare 3               selection
  },
  0x20 => reg32 ccer {  //! capture/compare enable           register
    13 => cc4p,  //= Capture/Compare 3 output               Polarity
    12 => cc4e,  //= Capture/Compare 4 output               enable
    9 => cc3p,  //= Capture/Compare 3 output               Polarity
    8 => cc3e,  //= Capture/Compare 3 output               enable
    5 => cc2p,  //= Capture/Compare 2 output               Polarity
    4 => cc2e,  //= Capture/Compare 2 output               enable
    1 => cc1p,  //= Capture/Compare 1 output               Polarity
    0 => cc1e,  //= Capture/Compare 1 output               enable
  },
  0x24 => reg32 cnt {  //! counter
    15..0 => cnt,  //= counter value
  },
  0x28 => reg32 psc {  //! prescaler
    15..0 => psc,  //= Prescaler value
  },
  0x2c => reg32 arr {  //! auto-reload register
    15..0 => arr,  //= Auto-reload value
  },
  0x34 => reg32 ccr1 {  //! capture/compare register 1
    15..0 => ccr1,  //= Capture/Compare 1 value
  },
  0x38 => reg32 ccr2 {  //! capture/compare register 2
    15..0 => ccr2,  //= Capture/Compare 2 value
  },
  0x3c => reg32 ccr3 {  //! capture/compare register 3
    15..0 => ccr3,  //= Capture/Compare value
  },
  0x40 => reg32 ccr4 {  //! capture/compare register 4
    15..0 => ccr4,  //= Capture/Compare value
  },
  0x48 => reg32 dcr {  //! DMA control register
    12..8 => dbl,  //= DMA burst length
    4..0 => dba,  //= DMA base address
  },
  0x4c => reg32 dmar {  //! DMA address for full transfer
    15..0 => dmab,  //= DMA register for burst               accesses
  },
});
ioregs! (TIM9 @ 0x40014c00 = {  //! General purpose timer
  0x00 => reg32 cr1 {  //! control register 1
    9..8 => ckd,  //= Clock division
    7 => arpe,  //= Auto-reload preload enable
    3 => opm,  //= One-pulse mode
    2 => urs,  //= Update request source
    1 => udis,  //= Update disable
    0 => cen,  //= Counter enable
  },
  0x04 => reg32 cr2 {  //! control register 2
    6..4 => mms,  //= Master mode selection
  },
  0x08 => reg32 smcr {  //! slave mode control register
    7 => msm,  //= Master/Slave mode
    6..4 => ts,  //= Trigger selection
    2..0 => sms,  //= Slave mode selection
  },
  0x0c => reg32 dier {  //! DMA/Interrupt enable register
    6 => tie,  //= Trigger interrupt enable
    2 => cc2ie,  //= Capture/Compare 2 interrupt               enable
    1 => cc1ie,  //= Capture/Compare 1 interrupt               enable
    0 => uie,  //= Update interrupt enable
  },
  0x10 => reg32 sr {  //! status register
    10 => cc2of,  //= Capture/compare 2 overcapture               flag
    9 => cc1of,  //= Capture/Compare 1 overcapture               flag
    6 => tif,  //= Trigger interrupt flag
    2 => cc2if,  //= Capture/Compare 2 interrupt               flag
    1 => cc1if,  //= Capture/compare 1 interrupt               flag
    0 => uif,  //= Update interrupt flag
  },
  0x14 => reg32 egr {  //! event generation register
    6 => tg: wo,  //= Trigger generation
    2 => cc2g: wo,  //= Capture/compare 2               generation
    1 => cc1g: wo,  //= Capture/compare 1               generation
    0 => ug: wo,  //= Update generation
  },
  0x18 => reg32 ccmr1_output {  //! capture/compare mode register 1 (output           mode)
    14..12 => oc2m,  //= Output Compare 2 mode
    11 => oc2pe,  //= Output Compare 2 preload               enable
    10 => oc2fe,  //= Output Compare 2 fast               enable
    9..8 => cc2s,  //= Capture/Compare 2               selection
    6..4 => oc1m,  //= Output Compare 1 mode
    3 => oc1pe,  //= Output Compare 1 preload               enable
    2 => oc1fe,  //= Output Compare 1 fast               enable
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x18 => reg32 ccmr1_input {  //! capture/compare mode register 1 (input           mode)
    15..12 => ic2f,  //= Input capture 2 filter
    11..10 => ic2psc,  //= Input capture 2 prescaler
    9..8 => cc2s,  //= Capture/Compare 2               selection
    7..4 => ic1f,  //= Input capture 1 filter
    3..2 => ic1psc,  //= Input capture 1 prescaler
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x20 => reg32 ccer {  //! capture/compare enable           register
    7 => cc2np,  //= Capture/Compare 2 output               Polarity
    5 => cc2p,  //= Capture/Compare 2 output               Polarity
    4 => cc2e,  //= Capture/Compare 2 output               enable
    3 => cc1np,  //= Capture/Compare 1 output               Polarity
    1 => cc1p,  //= Capture/Compare 1 output               Polarity
    0 => cc1e,  //= Capture/Compare 1 output               enable
  },
  0x24 => reg32 cnt {  //! counter
    15..0 => cnt,  //= counter value
  },
  0x28 => reg32 psc {  //! prescaler
    15..0 => psc,  //= Prescaler value
  },
  0x2c => reg32 arr {  //! auto-reload register
    15..0 => arr,  //= Auto-reload value
  },
  0x34 => reg32 ccr1 {  //! capture/compare register 1
    15..0 => ccr1,  //= Capture/Compare 1 value
  },
  0x38 => reg32 ccr2 {  //! capture/compare register 2
    15..0 => ccr2,  //= Capture/Compare 2 value
  },
});
ioregs! (TIM12 @ 0x40001800 = {  //! General purpose timer
  0x00 => reg32 cr1 {  //! control register 1
    9..8 => ckd,  //= Clock division
    7 => arpe,  //= Auto-reload preload enable
    3 => opm,  //= One-pulse mode
    2 => urs,  //= Update request source
    1 => udis,  //= Update disable
    0 => cen,  //= Counter enable
  },
  0x04 => reg32 cr2 {  //! control register 2
    6..4 => mms,  //= Master mode selection
  },
  0x08 => reg32 smcr {  //! slave mode control register
    7 => msm,  //= Master/Slave mode
    6..4 => ts,  //= Trigger selection
    2..0 => sms,  //= Slave mode selection
  },
  0x0c => reg32 dier {  //! DMA/Interrupt enable register
    6 => tie,  //= Trigger interrupt enable
    2 => cc2ie,  //= Capture/Compare 2 interrupt               enable
    1 => cc1ie,  //= Capture/Compare 1 interrupt               enable
    0 => uie,  //= Update interrupt enable
  },
  0x10 => reg32 sr {  //! status register
    10 => cc2of,  //= Capture/compare 2 overcapture               flag
    9 => cc1of,  //= Capture/Compare 1 overcapture               flag
    6 => tif,  //= Trigger interrupt flag
    2 => cc2if,  //= Capture/Compare 2 interrupt               flag
    1 => cc1if,  //= Capture/compare 1 interrupt               flag
    0 => uif,  //= Update interrupt flag
  },
  0x14 => reg32 egr {  //! event generation register
    6 => tg: wo,  //= Trigger generation
    2 => cc2g: wo,  //= Capture/compare 2               generation
    1 => cc1g: wo,  //= Capture/compare 1               generation
    0 => ug: wo,  //= Update generation
  },
  0x18 => reg32 ccmr1_output {  //! capture/compare mode register 1 (output           mode)
    14..12 => oc2m,  //= Output Compare 2 mode
    11 => oc2pe,  //= Output Compare 2 preload               enable
    10 => oc2fe,  //= Output Compare 2 fast               enable
    9..8 => cc2s,  //= Capture/Compare 2               selection
    6..4 => oc1m,  //= Output Compare 1 mode
    3 => oc1pe,  //= Output Compare 1 preload               enable
    2 => oc1fe,  //= Output Compare 1 fast               enable
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x18 => reg32 ccmr1_input {  //! capture/compare mode register 1 (input           mode)
    15..12 => ic2f,  //= Input capture 2 filter
    11..10 => ic2psc,  //= Input capture 2 prescaler
    9..8 => cc2s,  //= Capture/Compare 2               selection
    7..4 => ic1f,  //= Input capture 1 filter
    3..2 => ic1psc,  //= Input capture 1 prescaler
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x20 => reg32 ccer {  //! capture/compare enable           register
    7 => cc2np,  //= Capture/Compare 2 output               Polarity
    5 => cc2p,  //= Capture/Compare 2 output               Polarity
    4 => cc2e,  //= Capture/Compare 2 output               enable
    3 => cc1np,  //= Capture/Compare 1 output               Polarity
    1 => cc1p,  //= Capture/Compare 1 output               Polarity
    0 => cc1e,  //= Capture/Compare 1 output               enable
  },
  0x24 => reg32 cnt {  //! counter
    15..0 => cnt,  //= counter value
  },
  0x28 => reg32 psc {  //! prescaler
    15..0 => psc,  //= Prescaler value
  },
  0x2c => reg32 arr {  //! auto-reload register
    15..0 => arr,  //= Auto-reload value
  },
  0x34 => reg32 ccr1 {  //! capture/compare register 1
    15..0 => ccr1,  //= Capture/Compare 1 value
  },
  0x38 => reg32 ccr2 {  //! capture/compare register 2
    15..0 => ccr2,  //= Capture/Compare 2 value
  },
});
ioregs! (TIM10 @ 0x40015000 = {  //! General purpose timer
  0x00 => reg32 cr1 {  //! control register 1
    9..8 => ckd,  //= Clock division
    7 => arpe,  //= Auto-reload preload enable
    2 => urs,  //= Update request source
    1 => udis,  //= Update disable
    0 => cen,  //= Counter enable
  },
  0x04 => reg32 cr2 {  //! control register 2
    6..4 => mms,  //= Master mode selection
  },
  0x0c => reg32 dier {  //! DMA/Interrupt enable register
    1 => cc1ie,  //= Capture/Compare 1 interrupt               enable
    0 => uie,  //= Update interrupt enable
  },
  0x10 => reg32 sr {  //! status register
    9 => cc1of,  //= Capture/Compare 1 overcapture               flag
    1 => cc1if,  //= Capture/compare 1 interrupt               flag
    0 => uif,  //= Update interrupt flag
  },
  0x14 => reg32 egr {  //! event generation register
    1 => cc1g: wo,  //= Capture/compare 1               generation
    0 => ug: wo,  //= Update generation
  },
  0x18 => reg32 ccmr1_output {  //! capture/compare mode register (output           mode)
    6..4 => oc1m,  //= Output Compare 1 mode
    3 => oc1pe,  //= Output Compare 1 preload               enable
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x18 => reg32 ccmr1_input {  //! capture/compare mode register (input           mode)
    7..4 => ic1f,  //= Input capture 1 filter
    3..2 => ic1psc,  //= Input capture 1 prescaler
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x20 => reg32 ccer {  //! capture/compare enable           register
    3 => cc1np,  //= Capture/Compare 1 output               Polarity
    1 => cc1p,  //= Capture/Compare 1 output               Polarity
    0 => cc1e,  //= Capture/Compare 1 output               enable
  },
  0x24 => reg32 cnt {  //! counter
    15..0 => cnt,  //= counter value
  },
  0x28 => reg32 psc {  //! prescaler
    15..0 => psc,  //= Prescaler value
  },
  0x2c => reg32 arr {  //! auto-reload register
    15..0 => arr,  //= Auto-reload value
  },
  0x34 => reg32 ccr1 {  //! capture/compare register 1
    15..0 => ccr1,  //= Capture/Compare 1 value
  },
});
ioregs! (TIM11 @ 0x40015400 = {  //! General purpose timer
  0x00 => reg32 cr1 {  //! control register 1
    9..8 => ckd,  //= Clock division
    7 => arpe,  //= Auto-reload preload enable
    2 => urs,  //= Update request source
    1 => udis,  //= Update disable
    0 => cen,  //= Counter enable
  },
  0x04 => reg32 cr2 {  //! control register 2
    6..4 => mms,  //= Master mode selection
  },
  0x0c => reg32 dier {  //! DMA/Interrupt enable register
    1 => cc1ie,  //= Capture/Compare 1 interrupt               enable
    0 => uie,  //= Update interrupt enable
  },
  0x10 => reg32 sr {  //! status register
    9 => cc1of,  //= Capture/Compare 1 overcapture               flag
    1 => cc1if,  //= Capture/compare 1 interrupt               flag
    0 => uif,  //= Update interrupt flag
  },
  0x14 => reg32 egr {  //! event generation register
    1 => cc1g: wo,  //= Capture/compare 1               generation
    0 => ug: wo,  //= Update generation
  },
  0x18 => reg32 ccmr1_output {  //! capture/compare mode register (output           mode)
    6..4 => oc1m,  //= Output Compare 1 mode
    3 => oc1pe,  //= Output Compare 1 preload               enable
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x18 => reg32 ccmr1_input {  //! capture/compare mode register (input           mode)
    7..4 => ic1f,  //= Input capture 1 filter
    3..2 => ic1psc,  //= Input capture 1 prescaler
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x20 => reg32 ccer {  //! capture/compare enable           register
    3 => cc1np,  //= Capture/Compare 1 output               Polarity
    1 => cc1p,  //= Capture/Compare 1 output               Polarity
    0 => cc1e,  //= Capture/Compare 1 output               enable
  },
  0x24 => reg32 cnt {  //! counter
    15..0 => cnt,  //= counter value
  },
  0x28 => reg32 psc {  //! prescaler
    15..0 => psc,  //= Prescaler value
  },
  0x2c => reg32 arr {  //! auto-reload register
    15..0 => arr,  //= Auto-reload value
  },
  0x34 => reg32 ccr1 {  //! capture/compare register 1
    15..0 => ccr1,  //= Capture/Compare 1 value
  },
});
ioregs! (TIM13 @ 0x40001c00 = {  //! General purpose timer
  0x00 => reg32 cr1 {  //! control register 1
    9..8 => ckd,  //= Clock division
    7 => arpe,  //= Auto-reload preload enable
    2 => urs,  //= Update request source
    1 => udis,  //= Update disable
    0 => cen,  //= Counter enable
  },
  0x04 => reg32 cr2 {  //! control register 2
    6..4 => mms,  //= Master mode selection
  },
  0x0c => reg32 dier {  //! DMA/Interrupt enable register
    1 => cc1ie,  //= Capture/Compare 1 interrupt               enable
    0 => uie,  //= Update interrupt enable
  },
  0x10 => reg32 sr {  //! status register
    9 => cc1of,  //= Capture/Compare 1 overcapture               flag
    1 => cc1if,  //= Capture/compare 1 interrupt               flag
    0 => uif,  //= Update interrupt flag
  },
  0x14 => reg32 egr {  //! event generation register
    1 => cc1g: wo,  //= Capture/compare 1               generation
    0 => ug: wo,  //= Update generation
  },
  0x18 => reg32 ccmr1_output {  //! capture/compare mode register (output           mode)
    6..4 => oc1m,  //= Output Compare 1 mode
    3 => oc1pe,  //= Output Compare 1 preload               enable
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x18 => reg32 ccmr1_input {  //! capture/compare mode register (input           mode)
    7..4 => ic1f,  //= Input capture 1 filter
    3..2 => ic1psc,  //= Input capture 1 prescaler
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x20 => reg32 ccer {  //! capture/compare enable           register
    3 => cc1np,  //= Capture/Compare 1 output               Polarity
    1 => cc1p,  //= Capture/Compare 1 output               Polarity
    0 => cc1e,  //= Capture/Compare 1 output               enable
  },
  0x24 => reg32 cnt {  //! counter
    15..0 => cnt,  //= counter value
  },
  0x28 => reg32 psc {  //! prescaler
    15..0 => psc,  //= Prescaler value
  },
  0x2c => reg32 arr {  //! auto-reload register
    15..0 => arr,  //= Auto-reload value
  },
  0x34 => reg32 ccr1 {  //! capture/compare register 1
    15..0 => ccr1,  //= Capture/Compare 1 value
  },
});
ioregs! (TIM14 @ 0x40002000 = {  //! General purpose timer
  0x00 => reg32 cr1 {  //! control register 1
    9..8 => ckd,  //= Clock division
    7 => arpe,  //= Auto-reload preload enable
    2 => urs,  //= Update request source
    1 => udis,  //= Update disable
    0 => cen,  //= Counter enable
  },
  0x04 => reg32 cr2 {  //! control register 2
    6..4 => mms,  //= Master mode selection
  },
  0x0c => reg32 dier {  //! DMA/Interrupt enable register
    1 => cc1ie,  //= Capture/Compare 1 interrupt               enable
    0 => uie,  //= Update interrupt enable
  },
  0x10 => reg32 sr {  //! status register
    9 => cc1of,  //= Capture/Compare 1 overcapture               flag
    1 => cc1if,  //= Capture/compare 1 interrupt               flag
    0 => uif,  //= Update interrupt flag
  },
  0x14 => reg32 egr {  //! event generation register
    1 => cc1g: wo,  //= Capture/compare 1               generation
    0 => ug: wo,  //= Update generation
  },
  0x18 => reg32 ccmr1_output {  //! capture/compare mode register (output           mode)
    6..4 => oc1m,  //= Output Compare 1 mode
    3 => oc1pe,  //= Output Compare 1 preload               enable
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x18 => reg32 ccmr1_input {  //! capture/compare mode register (input           mode)
    7..4 => ic1f,  //= Input capture 1 filter
    3..2 => ic1psc,  //= Input capture 1 prescaler
    1..0 => cc1s,  //= Capture/Compare 1               selection
  },
  0x20 => reg32 ccer {  //! capture/compare enable           register
    3 => cc1np,  //= Capture/Compare 1 output               Polarity
    1 => cc1p,  //= Capture/Compare 1 output               Polarity
    0 => cc1e,  //= Capture/Compare 1 output               enable
  },
  0x24 => reg32 cnt {  //! counter
    15..0 => cnt,  //= counter value
  },
  0x28 => reg32 psc {  //! prescaler
    15..0 => psc,  //= Prescaler value
  },
  0x2c => reg32 arr {  //! auto-reload register
    15..0 => arr,  //= Auto-reload value
  },
  0x34 => reg32 ccr1 {  //! capture/compare register 1
    15..0 => ccr1,  //= Capture/Compare 1 value
  },
});
ioregs! (TIM6 @ 0x40001000 = {  //! Basic timer
  0x00 => reg32 cr1 {  //! control register 1
    7 => arpe,  //= Auto-reload preload enable
    3 => opm,  //= One-pulse mode
    2 => urs,  //= Update request source
    1 => udis,  //= Update disable
    0 => cen,  //= Counter enable
  },
  0x04 => reg32 cr2 {  //! control register 2
    6..4 => mms,  //= Master mode selection
  },
  0x0c => reg32 dier {  //! DMA/Interrupt enable register
    8 => ude,  //= Update DMA request enable
    0 => uie,  //= Update interrupt enable
  },
  0x10 => reg32 sr {  //! status register
    0 => uif,  //= Update interrupt flag
  },
  0x14 => reg32 egr {  //! event generation register
    0 => ug: wo,  //= Update generation
  },
  0x24 => reg32 cnt {  //! counter
    15..0 => cnt,  //= Low counter value
  },
  0x28 => reg32 psc {  //! prescaler
    15..0 => psc,  //= Prescaler value
  },
  0x2c => reg32 arr {  //! auto-reload register
    15..0 => arr,  //= Low Auto-reload value
  },
});
ioregs! (TIM7 @ 0x40001400 = {  //! Basic timer
  0x00 => reg32 cr1 {  //! control register 1
    7 => arpe,  //= Auto-reload preload enable
    3 => opm,  //= One-pulse mode
    2 => urs,  //= Update request source
    1 => udis,  //= Update disable
    0 => cen,  //= Counter enable
  },
  0x04 => reg32 cr2 {  //! control register 2
    6..4 => mms,  //= Master mode selection
  },
  0x0c => reg32 dier {  //! DMA/Interrupt enable register
    8 => ude,  //= Update DMA request enable
    0 => uie,  //= Update interrupt enable
  },
  0x10 => reg32 sr {  //! status register
    0 => uif,  //= Update interrupt flag
  },
  0x14 => reg32 egr {  //! event generation register
    0 => ug: wo,  //= Update generation
  },
  0x24 => reg32 cnt {  //! counter
    15..0 => cnt,  //= Low counter value
  },
  0x28 => reg32 psc {  //! prescaler
    15..0 => psc,  //= Prescaler value
  },
  0x2c => reg32 arr {  //! auto-reload register
    15..0 => arr,  //= Low Auto-reload value
  },
});
ioregs! (I2C1 @ 0x40005400 = {  //! Inter integrated circuit
  0x00 => reg32 cr1 {  //! Control register 1
    15 => swrst,  //= Software reset
    13 => alert,  //= SMBus alert
    12 => pec,  //= Packet error checking
    11 => pos,  //= Acknowledge/PEC Position (for data               reception)
    10 => ack,  //= Acknowledge enable
    9 => stop,  //= Stop generation
    8 => start,  //= Start generation
    7 => nostretch,  //= Clock stretching disable (Slave               mode)
    6 => engc,  //= General call enable
    5 => enpec,  //= PEC enable
    4 => enarp,  //= ARP enable
    3 => smbtype,  //= SMBus type
    1 => smbus,  //= SMBus mode
    0 => pe,  //= Peripheral enable
  },
  0x04 => reg32 cr2 {  //! Control register 2
    12 => last,  //= DMA last transfer
    11 => dmaen,  //= DMA requests enable
    10 => itbufen,  //= Buffer interrupt enable
    9 => itevten,  //= Event interrupt enable
    8 => iterren,  //= Error interrupt enable
    5..0 => freq,  //= Peripheral clock frequency
  },
  0x08 => reg32 oar1 {  //! Own address register 1
    15 => addmode,  //= Addressing mode (slave               mode)
    9..8 => add10,  //= Interface address
    7..1 => add7,  //= Interface address
    0 => add0,  //= Interface address
  },
  0x0c => reg32 oar2 {  //! Own address register 2
    7..1 => add2,  //= Interface address
    0 => endual,  //= Dual addressing mode               enable
  },
  0x10 => reg32 dr {  //! Data register
    7..0 => dr,  //= 8-bit data register
  },
  0x14 => reg32 sr1 {  //! Status register 1
    15 => smbalert,  //= SMBus alert
    14 => timeout,  //= Timeout or Tlow error
    12 => pecerr,  //= PEC Error in reception
    11 => ovr,  //= Overrun/Underrun
    10 => af,  //= Acknowledge failure
    9 => arlo,  //= Arbitration lost (master               mode)
    8 => berr,  //= Bus error
    7 => txe: ro,  //= Data register empty               (transmitters)
    6 => rxne: ro,  //= Data register not empty               (receivers)
    4 => stopf: ro,  //= Stop detection (slave               mode)
    3 => add10: ro,  //= 10-bit header sent (Master               mode)
    2 => btf: ro,  //= Byte transfer finished
    1 => addr: ro,  //= Address sent (master mode)/matched               (slave mode)
    0 => sb: ro,  //= Start bit (Master mode)
  },
  0x18 => reg32 sr2 {  //! Status register 2
    15..8 => pec: ro,  //= acket error checking               register
    7 => dualf: ro,  //= Dual flag (Slave mode)
    6 => smbhost: ro,  //= SMBus host header (Slave               mode)
    5 => smbdefault: ro,  //= SMBus device default address (Slave               mode)
    4 => gencall: ro,  //= General call address (Slave               mode)
    2 => tra: ro,  //= Transmitter/receiver
    1 => busy: ro,  //= Bus busy
    0 => msl: ro,  //= Master/slave
  },
  0x1c => reg32 ccr {  //! Clock control register
    15 => f_s,  //= I2C master mode selection
    14 => duty,  //= Fast mode duty cycle
    11..0 => ccr,  //= Clock control register in Fast/Standard               mode (Master mode)
  },
  0x20 => reg32 trise {  //! TRISE register
    5..0 => trise,  //= Maximum rise time in Fast/Standard mode               (Master mode)
  },
});
ioregs! (I2C2 @ 0x40005800 = {  //! Inter integrated circuit
  0x00 => reg32 cr1 {  //! Control register 1
    15 => swrst,  //= Software reset
    13 => alert,  //= SMBus alert
    12 => pec,  //= Packet error checking
    11 => pos,  //= Acknowledge/PEC Position (for data               reception)
    10 => ack,  //= Acknowledge enable
    9 => stop,  //= Stop generation
    8 => start,  //= Start generation
    7 => nostretch,  //= Clock stretching disable (Slave               mode)
    6 => engc,  //= General call enable
    5 => enpec,  //= PEC enable
    4 => enarp,  //= ARP enable
    3 => smbtype,  //= SMBus type
    1 => smbus,  //= SMBus mode
    0 => pe,  //= Peripheral enable
  },
  0x04 => reg32 cr2 {  //! Control register 2
    12 => last,  //= DMA last transfer
    11 => dmaen,  //= DMA requests enable
    10 => itbufen,  //= Buffer interrupt enable
    9 => itevten,  //= Event interrupt enable
    8 => iterren,  //= Error interrupt enable
    5..0 => freq,  //= Peripheral clock frequency
  },
  0x08 => reg32 oar1 {  //! Own address register 1
    15 => addmode,  //= Addressing mode (slave               mode)
    9..8 => add10,  //= Interface address
    7..1 => add7,  //= Interface address
    0 => add0,  //= Interface address
  },
  0x0c => reg32 oar2 {  //! Own address register 2
    7..1 => add2,  //= Interface address
    0 => endual,  //= Dual addressing mode               enable
  },
  0x10 => reg32 dr {  //! Data register
    7..0 => dr,  //= 8-bit data register
  },
  0x14 => reg32 sr1 {  //! Status register 1
    15 => smbalert,  //= SMBus alert
    14 => timeout,  //= Timeout or Tlow error
    12 => pecerr,  //= PEC Error in reception
    11 => ovr,  //= Overrun/Underrun
    10 => af,  //= Acknowledge failure
    9 => arlo,  //= Arbitration lost (master               mode)
    8 => berr,  //= Bus error
    7 => txe: ro,  //= Data register empty               (transmitters)
    6 => rxne: ro,  //= Data register not empty               (receivers)
    4 => stopf: ro,  //= Stop detection (slave               mode)
    3 => add10: ro,  //= 10-bit header sent (Master               mode)
    2 => btf: ro,  //= Byte transfer finished
    1 => addr: ro,  //= Address sent (master mode)/matched               (slave mode)
    0 => sb: ro,  //= Start bit (Master mode)
  },
  0x18 => reg32 sr2 {  //! Status register 2
    15..8 => pec: ro,  //= acket error checking               register
    7 => dualf: ro,  //= Dual flag (Slave mode)
    6 => smbhost: ro,  //= SMBus host header (Slave               mode)
    5 => smbdefault: ro,  //= SMBus device default address (Slave               mode)
    4 => gencall: ro,  //= General call address (Slave               mode)
    2 => tra: ro,  //= Transmitter/receiver
    1 => busy: ro,  //= Bus busy
    0 => msl: ro,  //= Master/slave
  },
  0x1c => reg32 ccr {  //! Clock control register
    15 => f_s,  //= I2C master mode selection
    14 => duty,  //= Fast mode duty cycle
    11..0 => ccr,  //= Clock control register in Fast/Standard               mode (Master mode)
  },
  0x20 => reg32 trise {  //! TRISE register
    5..0 => trise,  //= Maximum rise time in Fast/Standard mode               (Master mode)
  },
});
ioregs! (SPI1 @ 0x40013000 = {  //! Serial peripheral interface
  0x00 => reg32 cr1 {  //! control register 1
    15 => bidimode,  //= Bidirectional data mode               enable
    14 => bidioe,  //= Output enable in bidirectional               mode
    13 => crcen,  //= Hardware CRC calculation               enable
    12 => crcnext,  //= CRC transfer next
    11 => dff,  //= Data frame format
    10 => rxonly,  //= Receive only
    9 => ssm,  //= Software slave management
    8 => ssi,  //= Internal slave select
    7 => lsbfirst,  //= Frame format
    6 => spe,  //= SPI enable
    5..3 => br,  //= Baud rate control
    2 => mstr,  //= Master selection
    1 => cpol,  //= Clock polarity
    0 => cpha,  //= Clock phase
  },
  0x04 => reg32 cr2 {  //! control register 2
    7 => txeie,  //= Tx buffer empty interrupt               enable
    6 => rxneie,  //= RX buffer not empty interrupt               enable
    5 => errie,  //= Error interrupt enable
    2 => ssoe,  //= SS output enable
    1 => txdmaen,  //= Tx buffer DMA enable
    0 => rxdmaen,  //= Rx buffer DMA enable
  },
  0x08 => reg32 sr {  //! status register
    7 => bsy: ro,  //= Busy flag
    6 => ovr: ro,  //= Overrun flag
    5 => modf: ro,  //= Mode fault
    4 => crcerr,  //= CRC error flag
    3 => udr: ro,  //= Underrun flag
    2 => chside: ro,  //= Channel side
    1 => txe: ro,  //= Transmit buffer empty
    0 => rxne: ro,  //= Receive buffer not empty
  },
  0x0c => reg32 dr {  //! data register
    15..0 => dr,  //= Data register
  },
  0x10 => reg32 crcpr {  //! CRC polynomial register
    15..0 => crcpoly,  //= CRC polynomial register
  },
  0x14 => reg32 rxcrcr {  //! RX CRC register
    15..0 => rxcrc: ro,  //= Rx CRC register
  },
  0x18 => reg32 txcrcr {  //! TX CRC register
    15..0 => txcrc: ro,  //= Tx CRC register
  },
  0x1c => reg32 i2scfgr {  //! I2S configuration register
    11 => i2smod,  //= I2S mode selection
    10 => i2se,  //= I2S Enable
    9..8 => i2scfg,  //= I2S configuration mode
    7 => pcmsync,  //= PCM frame synchronization
    5..4 => i2sstd,  //= I2S standard selection
    3 => ckpol,  //= Steady state clock               polarity
    2..1 => datlen,  //= Data length to be               transferred
    0 => chlen,  //= Channel length (number of bits per audio               channel)
  },
  0x20 => reg32 i2spr {  //! I2S prescaler register
    9 => mckoe,  //= Master clock output enable
    8 => odd,  //= Odd factor for the               prescaler
    7..0 => i2sdiv,  //= I2S Linear prescaler
  },
});
ioregs! (SPI2 @ 0x40003800 = {  //! Serial peripheral interface
  0x00 => reg32 cr1 {  //! control register 1
    15 => bidimode,  //= Bidirectional data mode               enable
    14 => bidioe,  //= Output enable in bidirectional               mode
    13 => crcen,  //= Hardware CRC calculation               enable
    12 => crcnext,  //= CRC transfer next
    11 => dff,  //= Data frame format
    10 => rxonly,  //= Receive only
    9 => ssm,  //= Software slave management
    8 => ssi,  //= Internal slave select
    7 => lsbfirst,  //= Frame format
    6 => spe,  //= SPI enable
    5..3 => br,  //= Baud rate control
    2 => mstr,  //= Master selection
    1 => cpol,  //= Clock polarity
    0 => cpha,  //= Clock phase
  },
  0x04 => reg32 cr2 {  //! control register 2
    7 => txeie,  //= Tx buffer empty interrupt               enable
    6 => rxneie,  //= RX buffer not empty interrupt               enable
    5 => errie,  //= Error interrupt enable
    2 => ssoe,  //= SS output enable
    1 => txdmaen,  //= Tx buffer DMA enable
    0 => rxdmaen,  //= Rx buffer DMA enable
  },
  0x08 => reg32 sr {  //! status register
    7 => bsy: ro,  //= Busy flag
    6 => ovr: ro,  //= Overrun flag
    5 => modf: ro,  //= Mode fault
    4 => crcerr,  //= CRC error flag
    3 => udr: ro,  //= Underrun flag
    2 => chside: ro,  //= Channel side
    1 => txe: ro,  //= Transmit buffer empty
    0 => rxne: ro,  //= Receive buffer not empty
  },
  0x0c => reg32 dr {  //! data register
    15..0 => dr,  //= Data register
  },
  0x10 => reg32 crcpr {  //! CRC polynomial register
    15..0 => crcpoly,  //= CRC polynomial register
  },
  0x14 => reg32 rxcrcr {  //! RX CRC register
    15..0 => rxcrc: ro,  //= Rx CRC register
  },
  0x18 => reg32 txcrcr {  //! TX CRC register
    15..0 => txcrc: ro,  //= Tx CRC register
  },
  0x1c => reg32 i2scfgr {  //! I2S configuration register
    11 => i2smod,  //= I2S mode selection
    10 => i2se,  //= I2S Enable
    9..8 => i2scfg,  //= I2S configuration mode
    7 => pcmsync,  //= PCM frame synchronization
    5..4 => i2sstd,  //= I2S standard selection
    3 => ckpol,  //= Steady state clock               polarity
    2..1 => datlen,  //= Data length to be               transferred
    0 => chlen,  //= Channel length (number of bits per audio               channel)
  },
  0x20 => reg32 i2spr {  //! I2S prescaler register
    9 => mckoe,  //= Master clock output enable
    8 => odd,  //= Odd factor for the               prescaler
    7..0 => i2sdiv,  //= I2S Linear prescaler
  },
});
ioregs! (SPI3 @ 0x40003c00 = {  //! Serial peripheral interface
  0x00 => reg32 cr1 {  //! control register 1
    15 => bidimode,  //= Bidirectional data mode               enable
    14 => bidioe,  //= Output enable in bidirectional               mode
    13 => crcen,  //= Hardware CRC calculation               enable
    12 => crcnext,  //= CRC transfer next
    11 => dff,  //= Data frame format
    10 => rxonly,  //= Receive only
    9 => ssm,  //= Software slave management
    8 => ssi,  //= Internal slave select
    7 => lsbfirst,  //= Frame format
    6 => spe,  //= SPI enable
    5..3 => br,  //= Baud rate control
    2 => mstr,  //= Master selection
    1 => cpol,  //= Clock polarity
    0 => cpha,  //= Clock phase
  },
  0x04 => reg32 cr2 {  //! control register 2
    7 => txeie,  //= Tx buffer empty interrupt               enable
    6 => rxneie,  //= RX buffer not empty interrupt               enable
    5 => errie,  //= Error interrupt enable
    2 => ssoe,  //= SS output enable
    1 => txdmaen,  //= Tx buffer DMA enable
    0 => rxdmaen,  //= Rx buffer DMA enable
  },
  0x08 => reg32 sr {  //! status register
    7 => bsy: ro,  //= Busy flag
    6 => ovr: ro,  //= Overrun flag
    5 => modf: ro,  //= Mode fault
    4 => crcerr,  //= CRC error flag
    3 => udr: ro,  //= Underrun flag
    2 => chside: ro,  //= Channel side
    1 => txe: ro,  //= Transmit buffer empty
    0 => rxne: ro,  //= Receive buffer not empty
  },
  0x0c => reg32 dr {  //! data register
    15..0 => dr,  //= Data register
  },
  0x10 => reg32 crcpr {  //! CRC polynomial register
    15..0 => crcpoly,  //= CRC polynomial register
  },
  0x14 => reg32 rxcrcr {  //! RX CRC register
    15..0 => rxcrc: ro,  //= Rx CRC register
  },
  0x18 => reg32 txcrcr {  //! TX CRC register
    15..0 => txcrc: ro,  //= Tx CRC register
  },
  0x1c => reg32 i2scfgr {  //! I2S configuration register
    11 => i2smod,  //= I2S mode selection
    10 => i2se,  //= I2S Enable
    9..8 => i2scfg,  //= I2S configuration mode
    7 => pcmsync,  //= PCM frame synchronization
    5..4 => i2sstd,  //= I2S standard selection
    3 => ckpol,  //= Steady state clock               polarity
    2..1 => datlen,  //= Data length to be               transferred
    0 => chlen,  //= Channel length (number of bits per audio               channel)
  },
  0x20 => reg32 i2spr {  //! I2S prescaler register
    9 => mckoe,  //= Master clock output enable
    8 => odd,  //= Odd factor for the               prescaler
    7..0 => i2sdiv,  //= I2S Linear prescaler
  },
});
ioregs! (USART1 @ 0x40013800 = {  //! Universal synchronous asynchronous receiver       transmitter
  0x00 => reg32 sr {  //! Status register
    9 => cts,  //= CTS flag
    8 => lbd,  //= LIN break detection flag
    7 => txe: ro,  //= Transmit data register               empty
    6 => tc,  //= Transmission complete
    5 => rxne,  //= Read data register not               empty
    4 => idle: ro,  //= IDLE line detected
    3 => ore: ro,  //= Overrun error
    2 => ne: ro,  //= Noise error flag
    1 => fe: ro,  //= Framing error
    0 => pe: ro,  //= Parity error
  },
  0x04 => reg32 dr {  //! Data register
    8..0 => dr,  //= Data value
  },
  0x08 => reg32 brr {  //! Baud rate register
    15..4 => div_mantissa,  //= mantissa of USARTDIV
    3..0 => div_fraction,  //= fraction of USARTDIV
  },
  0x0c => reg32 cr1 {  //! Control register 1
    13 => ue,  //= USART enable
    12 => m,  //= Word length
    11 => wake,  //= Wakeup method
    10 => pce,  //= Parity control enable
    9 => ps,  //= Parity selection
    8 => peie,  //= PE interrupt enable
    7 => txeie,  //= TXE interrupt enable
    6 => tcie,  //= Transmission complete interrupt               enable
    5 => rxneie,  //= RXNE interrupt enable
    4 => idleie,  //= IDLE interrupt enable
    3 => te,  //= Transmitter enable
    2 => re,  //= Receiver enable
    1 => rwu,  //= Receiver wakeup
    0 => sbk,  //= Send break
  },
  0x10 => reg32 cr2 {  //! Control register 2
    14 => linen,  //= LIN mode enable
    13..12 => stop,  //= STOP bits
    11 => clken,  //= Clock enable
    10 => cpol,  //= Clock polarity
    9 => cpha,  //= Clock phase
    8 => lbcl,  //= Last bit clock pulse
    6 => lbdie,  //= LIN break detection interrupt               enable
    5 => lbdl,  //= lin break detection length
    3..0 => add,  //= Address of the USART node
  },
  0x14 => reg32 cr3 {  //! Control register 3
    10 => ctsie,  //= CTS interrupt enable
    9 => ctse,  //= CTS enable
    8 => rtse,  //= RTS enable
    7 => dmat,  //= DMA enable transmitter
    6 => dmar,  //= DMA enable receiver
    5 => scen,  //= Smartcard mode enable
    4 => nack,  //= Smartcard NACK enable
    3 => hdsel,  //= Half-duplex selection
    2 => irlp,  //= IrDA low-power
    1 => iren,  //= IrDA mode enable
    0 => eie,  //= Error interrupt enable
  },
  0x18 => reg32 gtpr {  //! Guard time and prescaler           register
    15..8 => gt,  //= Guard time value
    7..0 => psc,  //= Prescaler value
  },
});
ioregs! (USART2 @ 0x40004400 = {  //! Universal synchronous asynchronous receiver       transmitter
  0x00 => reg32 sr {  //! Status register
    9 => cts,  //= CTS flag
    8 => lbd,  //= LIN break detection flag
    7 => txe: ro,  //= Transmit data register               empty
    6 => tc,  //= Transmission complete
    5 => rxne,  //= Read data register not               empty
    4 => idle: ro,  //= IDLE line detected
    3 => ore: ro,  //= Overrun error
    2 => ne: ro,  //= Noise error flag
    1 => fe: ro,  //= Framing error
    0 => pe: ro,  //= Parity error
  },
  0x04 => reg32 dr {  //! Data register
    8..0 => dr,  //= Data value
  },
  0x08 => reg32 brr {  //! Baud rate register
    15..4 => div_mantissa,  //= mantissa of USARTDIV
    3..0 => div_fraction,  //= fraction of USARTDIV
  },
  0x0c => reg32 cr1 {  //! Control register 1
    13 => ue,  //= USART enable
    12 => m,  //= Word length
    11 => wake,  //= Wakeup method
    10 => pce,  //= Parity control enable
    9 => ps,  //= Parity selection
    8 => peie,  //= PE interrupt enable
    7 => txeie,  //= TXE interrupt enable
    6 => tcie,  //= Transmission complete interrupt               enable
    5 => rxneie,  //= RXNE interrupt enable
    4 => idleie,  //= IDLE interrupt enable
    3 => te,  //= Transmitter enable
    2 => re,  //= Receiver enable
    1 => rwu,  //= Receiver wakeup
    0 => sbk,  //= Send break
  },
  0x10 => reg32 cr2 {  //! Control register 2
    14 => linen,  //= LIN mode enable
    13..12 => stop,  //= STOP bits
    11 => clken,  //= Clock enable
    10 => cpol,  //= Clock polarity
    9 => cpha,  //= Clock phase
    8 => lbcl,  //= Last bit clock pulse
    6 => lbdie,  //= LIN break detection interrupt               enable
    5 => lbdl,  //= lin break detection length
    3..0 => add,  //= Address of the USART node
  },
  0x14 => reg32 cr3 {  //! Control register 3
    10 => ctsie,  //= CTS interrupt enable
    9 => ctse,  //= CTS enable
    8 => rtse,  //= RTS enable
    7 => dmat,  //= DMA enable transmitter
    6 => dmar,  //= DMA enable receiver
    5 => scen,  //= Smartcard mode enable
    4 => nack,  //= Smartcard NACK enable
    3 => hdsel,  //= Half-duplex selection
    2 => irlp,  //= IrDA low-power
    1 => iren,  //= IrDA mode enable
    0 => eie,  //= Error interrupt enable
  },
  0x18 => reg32 gtpr {  //! Guard time and prescaler           register
    15..8 => gt,  //= Guard time value
    7..0 => psc,  //= Prescaler value
  },
});
ioregs! (USART3 @ 0x40004800 = {  //! Universal synchronous asynchronous receiver       transmitter
  0x00 => reg32 sr {  //! Status register
    9 => cts,  //= CTS flag
    8 => lbd,  //= LIN break detection flag
    7 => txe: ro,  //= Transmit data register               empty
    6 => tc,  //= Transmission complete
    5 => rxne,  //= Read data register not               empty
    4 => idle: ro,  //= IDLE line detected
    3 => ore: ro,  //= Overrun error
    2 => ne: ro,  //= Noise error flag
    1 => fe: ro,  //= Framing error
    0 => pe: ro,  //= Parity error
  },
  0x04 => reg32 dr {  //! Data register
    8..0 => dr,  //= Data value
  },
  0x08 => reg32 brr {  //! Baud rate register
    15..4 => div_mantissa,  //= mantissa of USARTDIV
    3..0 => div_fraction,  //= fraction of USARTDIV
  },
  0x0c => reg32 cr1 {  //! Control register 1
    13 => ue,  //= USART enable
    12 => m,  //= Word length
    11 => wake,  //= Wakeup method
    10 => pce,  //= Parity control enable
    9 => ps,  //= Parity selection
    8 => peie,  //= PE interrupt enable
    7 => txeie,  //= TXE interrupt enable
    6 => tcie,  //= Transmission complete interrupt               enable
    5 => rxneie,  //= RXNE interrupt enable
    4 => idleie,  //= IDLE interrupt enable
    3 => te,  //= Transmitter enable
    2 => re,  //= Receiver enable
    1 => rwu,  //= Receiver wakeup
    0 => sbk,  //= Send break
  },
  0x10 => reg32 cr2 {  //! Control register 2
    14 => linen,  //= LIN mode enable
    13..12 => stop,  //= STOP bits
    11 => clken,  //= Clock enable
    10 => cpol,  //= Clock polarity
    9 => cpha,  //= Clock phase
    8 => lbcl,  //= Last bit clock pulse
    6 => lbdie,  //= LIN break detection interrupt               enable
    5 => lbdl,  //= lin break detection length
    3..0 => add,  //= Address of the USART node
  },
  0x14 => reg32 cr3 {  //! Control register 3
    10 => ctsie,  //= CTS interrupt enable
    9 => ctse,  //= CTS enable
    8 => rtse,  //= RTS enable
    7 => dmat,  //= DMA enable transmitter
    6 => dmar,  //= DMA enable receiver
    5 => scen,  //= Smartcard mode enable
    4 => nack,  //= Smartcard NACK enable
    3 => hdsel,  //= Half-duplex selection
    2 => irlp,  //= IrDA low-power
    1 => iren,  //= IrDA mode enable
    0 => eie,  //= Error interrupt enable
  },
  0x18 => reg32 gtpr {  //! Guard time and prescaler           register
    15..8 => gt,  //= Guard time value
    7..0 => psc,  //= Prescaler value
  },
});
ioregs! (ADC1 @ 0x40012400 = {  //! Analog to digital converter
  0x00 => reg32 sr {  //! status register
    4 => strt,  //= Regular channel start flag
    3 => jstrt,  //= Injected channel start               flag
    2 => jeoc,  //= Injected channel end of               conversion
    1 => eoc,  //= Regular channel end of               conversion
    0 => awd,  //= Analog watchdog flag
  },
  0x04 => reg32 cr1 {  //! control register 1
    23 => awden,  //= Analog watchdog enable on regular               channels
    22 => jawden,  //= Analog watchdog enable on injected               channels
    19..16 => dualmod,  //= Dual mode selection
    15..13 => discnum,  //= Discontinuous mode channel               count
    12 => jdiscen,  //= Discontinuous mode on injected               channels
    11 => discen,  //= Discontinuous mode on regular               channels
    10 => jauto,  //= Automatic injected group               conversion
    9 => awdsgl,  //= Enable the watchdog on a single channel               in scan mode
    8 => scan,  //= Scan mode
    7 => jeocie,  //= Interrupt enable for injected               channels
    6 => awdie,  //= Analog watchdog interrupt               enable
    5 => eocie,  //= Interrupt enable for EOC
    4..0 => awdch,  //= Analog watchdog channel select               bits
  },
  0x08 => reg32 cr2 {  //! control register 2
    23 => tsvrefe,  //= Temperature sensor and VREFINT               enable
    22 => swstart,  //= Start conversion of regular               channels
    21 => jswstart,  //= Start conversion of injected               channels
    20 => exttrig,  //= External trigger conversion mode for               regular channels
    19..17 => extsel,  //= External event select for regular               group
    15 => jexttrig,  //= External trigger conversion mode for               injected channels
    14..12 => jextsel,  //= External event select for injected               group
    11 => align,  //= Data alignment
    8 => dma,  //= Direct memory access mode
    3 => rstcal,  //= Reset calibration
    2 => cal,  //= A/D calibration
    1 => cont,  //= Continuous conversion
    0 => adon,  //= A/D converter ON / OFF
  },
  0x0c => reg32 smpr1 {  //! sample time register 1
    2..0 => smp10,  //= Channel 10 sample time               selection
    5..3 => smp11,  //= Channel 11 sample time               selection
    8..6 => smp12,  //= Channel 12 sample time               selection
    11..9 => smp13,  //= Channel 13 sample time               selection
    14..12 => smp14,  //= Channel 14 sample time               selection
    17..15 => smp15,  //= Channel 15 sample time               selection
    20..18 => smp16,  //= Channel 16 sample time               selection
    23..21 => smp17,  //= Channel 17 sample time               selection
  },
  0x10 => reg32 smpr2 {  //! sample time register 2
    2..0 => smp0,  //= Channel 0 sample time               selection
    5..3 => smp1,  //= Channel 1 sample time               selection
    8..6 => smp2,  //= Channel 2 sample time               selection
    11..9 => smp3,  //= Channel 3 sample time               selection
    14..12 => smp4,  //= Channel 4 sample time               selection
    17..15 => smp5,  //= Channel 5 sample time               selection
    20..18 => smp6,  //= Channel 6 sample time               selection
    23..21 => smp7,  //= Channel 7 sample time               selection
    26..24 => smp8,  //= Channel 8 sample time               selection
    29..27 => smp9,  //= Channel 9 sample time               selection
  },
  0x14 => reg32 jofr1 {  //! injected channel data offset register           x
    11..0 => joffset1,  //= Data offset for injected channel               x
  },
  0x18 => reg32 jofr2 {  //! injected channel data offset register           x
    11..0 => joffset2,  //= Data offset for injected channel               x
  },
  0x1c => reg32 jofr3 {  //! injected channel data offset register           x
    11..0 => joffset3,  //= Data offset for injected channel               x
  },
  0x20 => reg32 jofr4 {  //! injected channel data offset register           x
    11..0 => joffset4,  //= Data offset for injected channel               x
  },
  0x24 => reg32 htr {  //! watchdog higher threshold           register
    11..0 => ht,  //= Analog watchdog higher               threshold
  },
  0x28 => reg32 ltr {  //! watchdog lower threshold           register
    11..0 => lt,  //= Analog watchdog lower               threshold
  },
  0x2c => reg32 sqr1 {  //! regular sequence register 1
    23..20 => l,  //= Regular channel sequence               length
    19..15 => sq16,  //= 16th conversion in regular               sequence
    14..10 => sq15,  //= 15th conversion in regular               sequence
    9..5 => sq14,  //= 14th conversion in regular               sequence
    4..0 => sq13,  //= 13th conversion in regular               sequence
  },
  0x30 => reg32 sqr2 {  //! regular sequence register 2
    29..25 => sq12,  //= 12th conversion in regular               sequence
    24..20 => sq11,  //= 11th conversion in regular               sequence
    19..15 => sq10,  //= 10th conversion in regular               sequence
    14..10 => sq9,  //= 9th conversion in regular               sequence
    9..5 => sq8,  //= 8th conversion in regular               sequence
    4..0 => sq7,  //= 7th conversion in regular               sequence
  },
  0x34 => reg32 sqr3 {  //! regular sequence register 3
    29..25 => sq6,  //= 6th conversion in regular               sequence
    24..20 => sq5,  //= 5th conversion in regular               sequence
    19..15 => sq4,  //= 4th conversion in regular               sequence
    14..10 => sq3,  //= 3rd conversion in regular               sequence
    9..5 => sq2,  //= 2nd conversion in regular               sequence
    4..0 => sq1,  //= 1st conversion in regular               sequence
  },
  0x38 => reg32 jsqr {  //! injected sequence register
    21..20 => jl,  //= Injected sequence length
    19..15 => jsq4,  //= 4th conversion in injected               sequence
    14..10 => jsq3,  //= 3rd conversion in injected               sequence
    9..5 => jsq2,  //= 2nd conversion in injected               sequence
    4..0 => jsq1,  //= 1st conversion in injected               sequence
  },
  0x3c => reg32 jdr1 {  //! injected data register x
    15..0 => jdata: ro,  //= Injected data
  },
  0x40 => reg32 jdr2 {  //! injected data register x
    15..0 => jdata: ro,  //= Injected data
  },
  0x44 => reg32 jdr3 {  //! injected data register x
    15..0 => jdata: ro,  //= Injected data
  },
  0x48 => reg32 jdr4 {  //! injected data register x
    15..0 => jdata: ro,  //= Injected data
  },
  0x4c => reg32 dr {  //! regular data register
    15..0 => data: ro,  //= Regular data
    31..16 => adc2data: ro,  //= ADC2 data
  },
});
ioregs! (ADC2 @ 0x40012800 = {  //! Analog to digital converter
  0x00 => reg32 sr {  //! status register
    4 => strt,  //= Regular channel start flag
    3 => jstrt,  //= Injected channel start               flag
    2 => jeoc,  //= Injected channel end of               conversion
    1 => eoc,  //= Regular channel end of               conversion
    0 => awd,  //= Analog watchdog flag
  },
  0x04 => reg32 cr1 {  //! control register 1
    23 => awden,  //= Analog watchdog enable on regular               channels
    22 => jawden,  //= Analog watchdog enable on injected               channels
    15..13 => discnum,  //= Discontinuous mode channel               count
    12 => jdiscen,  //= Discontinuous mode on injected               channels
    11 => discen,  //= Discontinuous mode on regular               channels
    10 => jauto,  //= Automatic injected group               conversion
    9 => awdsgl,  //= Enable the watchdog on a single channel               in scan mode
    8 => scan,  //= Scan mode
    7 => jeocie,  //= Interrupt enable for injected               channels
    6 => awdie,  //= Analog watchdog interrupt               enable
    5 => eocie,  //= Interrupt enable for EOC
    4..0 => awdch,  //= Analog watchdog channel select               bits
  },
  0x08 => reg32 cr2 {  //! control register 2
    23 => tsvrefe,  //= Temperature sensor and VREFINT               enable
    22 => swstart,  //= Start conversion of regular               channels
    21 => jswstart,  //= Start conversion of injected               channels
    20 => exttrig,  //= External trigger conversion mode for               regular channels
    19..17 => extsel,  //= External event select for regular               group
    15 => jexttrig,  //= External trigger conversion mode for               injected channels
    14..12 => jextsel,  //= External event select for injected               group
    11 => align,  //= Data alignment
    8 => dma,  //= Direct memory access mode
    3 => rstcal,  //= Reset calibration
    2 => cal,  //= A/D calibration
    1 => cont,  //= Continuous conversion
    0 => adon,  //= A/D converter ON / OFF
  },
  0x0c => reg32 smpr1 {  //! sample time register 1
    2..0 => smp10,  //= Channel 10 sample time               selection
    5..3 => smp11,  //= Channel 11 sample time               selection
    8..6 => smp12,  //= Channel 12 sample time               selection
    11..9 => smp13,  //= Channel 13 sample time               selection
    14..12 => smp14,  //= Channel 14 sample time               selection
    17..15 => smp15,  //= Channel 15 sample time               selection
    20..18 => smp16,  //= Channel 16 sample time               selection
    23..21 => smp17,  //= Channel 17 sample time               selection
  },
  0x10 => reg32 smpr2 {  //! sample time register 2
    2..0 => smp0,  //= Channel 0 sample time               selection
    5..3 => smp1,  //= Channel 1 sample time               selection
    8..6 => smp2,  //= Channel 2 sample time               selection
    11..9 => smp3,  //= Channel 3 sample time               selection
    14..12 => smp4,  //= Channel 4 sample time               selection
    17..15 => smp5,  //= Channel 5 sample time               selection
    20..18 => smp6,  //= Channel 6 sample time               selection
    23..21 => smp7,  //= Channel 7 sample time               selection
    26..24 => smp8,  //= Channel 8 sample time               selection
    29..27 => smp9,  //= Channel 9 sample time               selection
  },
  0x14 => reg32 jofr1 {  //! injected channel data offset register           x
    11..0 => joffset1,  //= Data offset for injected channel               x
  },
  0x18 => reg32 jofr2 {  //! injected channel data offset register           x
    11..0 => joffset2,  //= Data offset for injected channel               x
  },
  0x1c => reg32 jofr3 {  //! injected channel data offset register           x
    11..0 => joffset3,  //= Data offset for injected channel               x
  },
  0x20 => reg32 jofr4 {  //! injected channel data offset register           x
    11..0 => joffset4,  //= Data offset for injected channel               x
  },
  0x24 => reg32 htr {  //! watchdog higher threshold           register
    11..0 => ht,  //= Analog watchdog higher               threshold
  },
  0x28 => reg32 ltr {  //! watchdog lower threshold           register
    11..0 => lt,  //= Analog watchdog lower               threshold
  },
  0x2c => reg32 sqr1 {  //! regular sequence register 1
    23..20 => l,  //= Regular channel sequence               length
    19..15 => sq16,  //= 16th conversion in regular               sequence
    14..10 => sq15,  //= 15th conversion in regular               sequence
    9..5 => sq14,  //= 14th conversion in regular               sequence
    4..0 => sq13,  //= 13th conversion in regular               sequence
  },
  0x30 => reg32 sqr2 {  //! regular sequence register 2
    29..25 => sq12,  //= 12th conversion in regular               sequence
    24..20 => sq11,  //= 11th conversion in regular               sequence
    19..15 => sq10,  //= 10th conversion in regular               sequence
    14..10 => sq9,  //= 9th conversion in regular               sequence
    9..5 => sq8,  //= 8th conversion in regular               sequence
    4..0 => sq7,  //= 7th conversion in regular               sequence
  },
  0x34 => reg32 sqr3 {  //! regular sequence register 3
    29..25 => sq6,  //= 6th conversion in regular               sequence
    24..20 => sq5,  //= 5th conversion in regular               sequence
    19..15 => sq4,  //= 4th conversion in regular               sequence
    14..10 => sq3,  //= 3rd conversion in regular               sequence
    9..5 => sq2,  //= 2nd conversion in regular               sequence
    4..0 => sq1,  //= 1st conversion in regular               sequence
  },
  0x38 => reg32 jsqr {  //! injected sequence register
    21..20 => jl,  //= Injected sequence length
    19..15 => jsq4,  //= 4th conversion in injected               sequence
    14..10 => jsq3,  //= 3rd conversion in injected               sequence
    9..5 => jsq2,  //= 2nd conversion in injected               sequence
    4..0 => jsq1,  //= 1st conversion in injected               sequence
  },
  0x3c => reg32 jdr1 {  //! injected data register x
    15..0 => jdata: ro,  //= Injected data
  },
  0x40 => reg32 jdr2 {  //! injected data register x
    15..0 => jdata: ro,  //= Injected data
  },
  0x44 => reg32 jdr3 {  //! injected data register x
    15..0 => jdata: ro,  //= Injected data
  },
  0x48 => reg32 jdr4 {  //! injected data register x
    15..0 => jdata: ro,  //= Injected data
  },
  0x4c => reg32 dr {  //! regular data register
    15..0 => data: ro,  //= Regular data
  },
});
ioregs! (ADC3 @ 0x40013c00 = {  //! Analog to digital converter
  0x00 => reg32 sr {  //! status register
    4 => strt,  //= Regular channel start flag
    3 => jstrt,  //= Injected channel start               flag
    2 => jeoc,  //= Injected channel end of               conversion
    1 => eoc,  //= Regular channel end of               conversion
    0 => awd,  //= Analog watchdog flag
  },
  0x04 => reg32 cr1 {  //! control register 1
    23 => awden,  //= Analog watchdog enable on regular               channels
    22 => jawden,  //= Analog watchdog enable on injected               channels
    15..13 => discnum,  //= Discontinuous mode channel               count
    12 => jdiscen,  //= Discontinuous mode on injected               channels
    11 => discen,  //= Discontinuous mode on regular               channels
    10 => jauto,  //= Automatic injected group               conversion
    9 => awdsgl,  //= Enable the watchdog on a single channel               in scan mode
    8 => scan,  //= Scan mode
    7 => jeocie,  //= Interrupt enable for injected               channels
    6 => awdie,  //= Analog watchdog interrupt               enable
    5 => eocie,  //= Interrupt enable for EOC
    4..0 => awdch,  //= Analog watchdog channel select               bits
  },
  0x08 => reg32 cr2 {  //! control register 2
    23 => tsvrefe,  //= Temperature sensor and VREFINT               enable
    22 => swstart,  //= Start conversion of regular               channels
    21 => jswstart,  //= Start conversion of injected               channels
    20 => exttrig,  //= External trigger conversion mode for               regular channels
    19..17 => extsel,  //= External event select for regular               group
    15 => jexttrig,  //= External trigger conversion mode for               injected channels
    14..12 => jextsel,  //= External event select for injected               group
    11 => align,  //= Data alignment
    8 => dma,  //= Direct memory access mode
    3 => rstcal,  //= Reset calibration
    2 => cal,  //= A/D calibration
    1 => cont,  //= Continuous conversion
    0 => adon,  //= A/D converter ON / OFF
  },
  0x0c => reg32 smpr1 {  //! sample time register 1
    2..0 => smp10,  //= Channel 10 sample time               selection
    5..3 => smp11,  //= Channel 11 sample time               selection
    8..6 => smp12,  //= Channel 12 sample time               selection
    11..9 => smp13,  //= Channel 13 sample time               selection
    14..12 => smp14,  //= Channel 14 sample time               selection
    17..15 => smp15,  //= Channel 15 sample time               selection
    20..18 => smp16,  //= Channel 16 sample time               selection
    23..21 => smp17,  //= Channel 17 sample time               selection
  },
  0x10 => reg32 smpr2 {  //! sample time register 2
    2..0 => smp0,  //= Channel 0 sample time               selection
    5..3 => smp1,  //= Channel 1 sample time               selection
    8..6 => smp2,  //= Channel 2 sample time               selection
    11..9 => smp3,  //= Channel 3 sample time               selection
    14..12 => smp4,  //= Channel 4 sample time               selection
    17..15 => smp5,  //= Channel 5 sample time               selection
    20..18 => smp6,  //= Channel 6 sample time               selection
    23..21 => smp7,  //= Channel 7 sample time               selection
    26..24 => smp8,  //= Channel 8 sample time               selection
    29..27 => smp9,  //= Channel 9 sample time               selection
  },
  0x14 => reg32 jofr1 {  //! injected channel data offset register           x
    11..0 => joffset1,  //= Data offset for injected channel               x
  },
  0x18 => reg32 jofr2 {  //! injected channel data offset register           x
    11..0 => joffset2,  //= Data offset for injected channel               x
  },
  0x1c => reg32 jofr3 {  //! injected channel data offset register           x
    11..0 => joffset3,  //= Data offset for injected channel               x
  },
  0x20 => reg32 jofr4 {  //! injected channel data offset register           x
    11..0 => joffset4,  //= Data offset for injected channel               x
  },
  0x24 => reg32 htr {  //! watchdog higher threshold           register
    11..0 => ht,  //= Analog watchdog higher               threshold
  },
  0x28 => reg32 ltr {  //! watchdog lower threshold           register
    11..0 => lt,  //= Analog watchdog lower               threshold
  },
  0x2c => reg32 sqr1 {  //! regular sequence register 1
    23..20 => l,  //= Regular channel sequence               length
    19..15 => sq16,  //= 16th conversion in regular               sequence
    14..10 => sq15,  //= 15th conversion in regular               sequence
    9..5 => sq14,  //= 14th conversion in regular               sequence
    4..0 => sq13,  //= 13th conversion in regular               sequence
  },
  0x30 => reg32 sqr2 {  //! regular sequence register 2
    29..25 => sq12,  //= 12th conversion in regular               sequence
    24..20 => sq11,  //= 11th conversion in regular               sequence
    19..15 => sq10,  //= 10th conversion in regular               sequence
    14..10 => sq9,  //= 9th conversion in regular               sequence
    9..5 => sq8,  //= 8th conversion in regular               sequence
    4..0 => sq7,  //= 7th conversion in regular               sequence
  },
  0x34 => reg32 sqr3 {  //! regular sequence register 3
    29..25 => sq6,  //= 6th conversion in regular               sequence
    24..20 => sq5,  //= 5th conversion in regular               sequence
    19..15 => sq4,  //= 4th conversion in regular               sequence
    14..10 => sq3,  //= 3rd conversion in regular               sequence
    9..5 => sq2,  //= 2nd conversion in regular               sequence
    4..0 => sq1,  //= 1st conversion in regular               sequence
  },
  0x38 => reg32 jsqr {  //! injected sequence register
    21..20 => jl,  //= Injected sequence length
    19..15 => jsq4,  //= 4th conversion in injected               sequence
    14..10 => jsq3,  //= 3rd conversion in injected               sequence
    9..5 => jsq2,  //= 2nd conversion in injected               sequence
    4..0 => jsq1,  //= 1st conversion in injected               sequence
  },
  0x3c => reg32 jdr1 {  //! injected data register x
    15..0 => jdata: ro,  //= Injected data
  },
  0x40 => reg32 jdr2 {  //! injected data register x
    15..0 => jdata: ro,  //= Injected data
  },
  0x44 => reg32 jdr3 {  //! injected data register x
    15..0 => jdata: ro,  //= Injected data
  },
  0x48 => reg32 jdr4 {  //! injected data register x
    15..0 => jdata: ro,  //= Injected data
  },
  0x4c => reg32 dr {  //! regular data register
    15..0 => data: ro,  //= Regular data
  },
});
ioregs! (CAN @ 0x40006400 = {  //! Controller area network
  0x00 => reg32 can_mcr {  //! CAN_MCR
    16 => dbf,  //= DBF
    15 => reset,  //= RESET
    7 => ttcm,  //= TTCM
    6 => abom,  //= ABOM
    5 => awum,  //= AWUM
    4 => nart,  //= NART
    3 => rflm,  //= RFLM
    2 => txfp,  //= TXFP
    1 => sleep,  //= SLEEP
    0 => inrq,  //= INRQ
  },
  0x04 => reg32 can_msr {  //! CAN_MSR
    11 => rx: ro,  //= RX
    10 => samp: ro,  //= SAMP
    9 => rxm: ro,  //= RXM
    8 => txm: ro,  //= TXM
    4 => slaki,  //= SLAKI
    3 => wkui,  //= WKUI
    2 => erri,  //= ERRI
    1 => slak: ro,  //= SLAK
    0 => inak: ro,  //= INAK
  },
  0x08 => reg32 can_tsr {  //! CAN_TSR
    31 => low2: ro,  //= Lowest priority flag for mailbox               2
    30 => low1: ro,  //= Lowest priority flag for mailbox               1
    29 => low0: ro,  //= Lowest priority flag for mailbox               0
    28 => tme2: ro,  //= Lowest priority flag for mailbox               2
    27 => tme1: ro,  //= Lowest priority flag for mailbox               1
    26 => tme0: ro,  //= Lowest priority flag for mailbox               0
    25..24 => code: ro,  //= CODE
    23 => abrq2,  //= ABRQ2
    19 => terr2,  //= TERR2
    18 => alst2,  //= ALST2
    17 => txok2,  //= TXOK2
    16 => rqcp2,  //= RQCP2
    15 => abrq1,  //= ABRQ1
    11 => terr1,  //= TERR1
    10 => alst1,  //= ALST1
    9 => txok1,  //= TXOK1
    8 => rqcp1,  //= RQCP1
    7 => abrq0,  //= ABRQ0
    3 => terr0,  //= TERR0
    2 => alst0,  //= ALST0
    1 => txok0,  //= TXOK0
    0 => rqcp0,  //= RQCP0
  },
  0x0c => reg32 can_rf0r {  //! CAN_RF0R
    5 => rfom0,  //= RFOM0
    4 => fovr0,  //= FOVR0
    3 => full0,  //= FULL0
    1..0 => fmp0: ro,  //= FMP0
  },
  0x10 => reg32 can_rf1r {  //! CAN_RF1R
    5 => rfom1,  //= RFOM1
    4 => fovr1,  //= FOVR1
    3 => full1,  //= FULL1
    1..0 => fmp1: ro,  //= FMP1
  },
  0x14 => reg32 can_ier {  //! CAN_IER
    17 => slkie,  //= SLKIE
    16 => wkuie,  //= WKUIE
    15 => errie,  //= ERRIE
    11 => lecie,  //= LECIE
    10 => bofie,  //= BOFIE
    9 => epvie,  //= EPVIE
    8 => ewgie,  //= EWGIE
    6 => fovie1,  //= FOVIE1
    5 => ffie1,  //= FFIE1
    4 => fmpie1,  //= FMPIE1
    3 => fovie0,  //= FOVIE0
    2 => ffie0,  //= FFIE0
    1 => fmpie0,  //= FMPIE0
    0 => tmeie,  //= TMEIE
  },
  0x18 => reg32 can_esr {  //! CAN_ESR
    31..24 => rec: ro,  //= REC
    23..16 => tec: ro,  //= TEC
    6..4 => lec,  //= LEC
    2 => boff: ro,  //= BOFF
    1 => epvf: ro,  //= EPVF
    0 => ewgf: ro,  //= EWGF
  },
  0x1c => reg32 can_btr {  //! CAN_BTR
    31 => silm,  //= SILM
    30 => lbkm,  //= LBKM
    25..24 => sjw,  //= SJW
    22..20 => ts2,  //= TS2
    19..16 => ts1,  //= TS1
    9..0 => brp,  //= BRP
  },
  0x180 => reg32 can_ti0r {  //! CAN_TI0R
    31..21 => stid,  //= STID
    20..3 => exid,  //= EXID
    2 => ide,  //= IDE
    1 => rtr,  //= RTR
    0 => txrq,  //= TXRQ
  },
  0x184 => reg32 can_tdt0r {  //! CAN_TDT0R
    31..16 => time,  //= TIME
    8 => tgt,  //= TGT
    3..0 => dlc,  //= DLC
  },
  0x188 => reg32 can_tdl0r {  //! CAN_TDL0R
    31..24 => data3,  //= DATA3
    23..16 => data2,  //= DATA2
    15..8 => data1,  //= DATA1
    7..0 => data0,  //= DATA0
  },
  0x18c => reg32 can_tdh0r {  //! CAN_TDH0R
    31..24 => data7,  //= DATA7
    23..16 => data6,  //= DATA6
    15..8 => data5,  //= DATA5
    7..0 => data4,  //= DATA4
  },
  0x190 => reg32 can_ti1r {  //! CAN_TI1R
    31..21 => stid,  //= STID
    20..3 => exid,  //= EXID
    2 => ide,  //= IDE
    1 => rtr,  //= RTR
    0 => txrq,  //= TXRQ
  },
  0x194 => reg32 can_tdt1r {  //! CAN_TDT1R
    31..16 => time,  //= TIME
    8 => tgt,  //= TGT
    3..0 => dlc,  //= DLC
  },
  0x198 => reg32 can_tdl1r {  //! CAN_TDL1R
    31..24 => data3,  //= DATA3
    23..16 => data2,  //= DATA2
    15..8 => data1,  //= DATA1
    7..0 => data0,  //= DATA0
  },
  0x19c => reg32 can_tdh1r {  //! CAN_TDH1R
    31..24 => data7,  //= DATA7
    23..16 => data6,  //= DATA6
    15..8 => data5,  //= DATA5
    7..0 => data4,  //= DATA4
  },
  0x1a0 => reg32 can_ti2r {  //! CAN_TI2R
    31..21 => stid,  //= STID
    20..3 => exid,  //= EXID
    2 => ide,  //= IDE
    1 => rtr,  //= RTR
    0 => txrq,  //= TXRQ
  },
  0x1a4 => reg32 can_tdt2r {  //! CAN_TDT2R
    31..16 => time,  //= TIME
    8 => tgt,  //= TGT
    3..0 => dlc,  //= DLC
  },
  0x1a8 => reg32 can_tdl2r {  //! CAN_TDL2R
    31..24 => data3,  //= DATA3
    23..16 => data2,  //= DATA2
    15..8 => data1,  //= DATA1
    7..0 => data0,  //= DATA0
  },
  0x1ac => reg32 can_tdh2r {  //! CAN_TDH2R
    31..24 => data7,  //= DATA7
    23..16 => data6,  //= DATA6
    15..8 => data5,  //= DATA5
    7..0 => data4,  //= DATA4
  },
  0x1b0 => reg32 can_ri0r {  //! CAN_RI0R
    31..21 => stid: ro,  //= STID
    20..3 => exid: ro,  //= EXID
    2 => ide: ro,  //= IDE
    1 => rtr: ro,  //= RTR
  },
  0x1b4 => reg32 can_rdt0r {  //! CAN_RDT0R
    31..16 => time: ro,  //= TIME
    15..8 => fmi: ro,  //= FMI
    3..0 => dlc: ro,  //= DLC
  },
  0x1b8 => reg32 can_rdl0r {  //! CAN_RDL0R
    31..24 => data3: ro,  //= DATA3
    23..16 => data2: ro,  //= DATA2
    15..8 => data1: ro,  //= DATA1
    7..0 => data0: ro,  //= DATA0
  },
  0x1bc => reg32 can_rdh0r {  //! CAN_RDH0R
    31..24 => data7: ro,  //= DATA7
    23..16 => data6: ro,  //= DATA6
    15..8 => data5: ro,  //= DATA5
    7..0 => data4: ro,  //= DATA4
  },
  0x1c0 => reg32 can_ri1r {  //! CAN_RI1R
    31..21 => stid: ro,  //= STID
    20..3 => exid: ro,  //= EXID
    2 => ide: ro,  //= IDE
    1 => rtr: ro,  //= RTR
  },
  0x1c4 => reg32 can_rdt1r {  //! CAN_RDT1R
    31..16 => time: ro,  //= TIME
    15..8 => fmi: ro,  //= FMI
    3..0 => dlc: ro,  //= DLC
  },
  0x1c8 => reg32 can_rdl1r {  //! CAN_RDL1R
    31..24 => data3: ro,  //= DATA3
    23..16 => data2: ro,  //= DATA2
    15..8 => data1: ro,  //= DATA1
    7..0 => data0: ro,  //= DATA0
  },
  0x1cc => reg32 can_rdh1r {  //! CAN_RDH1R
    31..24 => data7: ro,  //= DATA7
    23..16 => data6: ro,  //= DATA6
    15..8 => data5: ro,  //= DATA5
    7..0 => data4: ro,  //= DATA4
  },
  0x200 => reg32 can_fmr {  //! CAN_FMR
    0 => finit,  //= FINIT
  },
  0x204 => reg32 can_fm1r {  //! CAN_FM1R
    0 => fbm0,  //= Filter mode
    1 => fbm1,  //= Filter mode
    2 => fbm2,  //= Filter mode
    3 => fbm3,  //= Filter mode
    4 => fbm4,  //= Filter mode
    5 => fbm5,  //= Filter mode
    6 => fbm6,  //= Filter mode
    7 => fbm7,  //= Filter mode
    8 => fbm8,  //= Filter mode
    9 => fbm9,  //= Filter mode
    10 => fbm10,  //= Filter mode
    11 => fbm11,  //= Filter mode
    12 => fbm12,  //= Filter mode
    13 => fbm13,  //= Filter mode
  },
  0x20c => reg32 can_fs1r {  //! CAN_FS1R
    0 => fsc0,  //= Filter scale configuration
    1 => fsc1,  //= Filter scale configuration
    2 => fsc2,  //= Filter scale configuration
    3 => fsc3,  //= Filter scale configuration
    4 => fsc4,  //= Filter scale configuration
    5 => fsc5,  //= Filter scale configuration
    6 => fsc6,  //= Filter scale configuration
    7 => fsc7,  //= Filter scale configuration
    8 => fsc8,  //= Filter scale configuration
    9 => fsc9,  //= Filter scale configuration
    10 => fsc10,  //= Filter scale configuration
    11 => fsc11,  //= Filter scale configuration
    12 => fsc12,  //= Filter scale configuration
    13 => fsc13,  //= Filter scale configuration
  },
  0x214 => reg32 can_ffa1r {  //! CAN_FFA1R
    0 => ffa0,  //= Filter FIFO assignment for filter               0
    1 => ffa1,  //= Filter FIFO assignment for filter               1
    2 => ffa2,  //= Filter FIFO assignment for filter               2
    3 => ffa3,  //= Filter FIFO assignment for filter               3
    4 => ffa4,  //= Filter FIFO assignment for filter               4
    5 => ffa5,  //= Filter FIFO assignment for filter               5
    6 => ffa6,  //= Filter FIFO assignment for filter               6
    7 => ffa7,  //= Filter FIFO assignment for filter               7
    8 => ffa8,  //= Filter FIFO assignment for filter               8
    9 => ffa9,  //= Filter FIFO assignment for filter               9
    10 => ffa10,  //= Filter FIFO assignment for filter               10
    11 => ffa11,  //= Filter FIFO assignment for filter               11
    12 => ffa12,  //= Filter FIFO assignment for filter               12
    13 => ffa13,  //= Filter FIFO assignment for filter               13
  },
  0x21c => reg32 can_fa1r {  //! CAN_FA1R
    0 => fact0,  //= Filter active
    1 => fact1,  //= Filter active
    2 => fact2,  //= Filter active
    3 => fact3,  //= Filter active
    4 => fact4,  //= Filter active
    5 => fact5,  //= Filter active
    6 => fact6,  //= Filter active
    7 => fact7,  //= Filter active
    8 => fact8,  //= Filter active
    9 => fact9,  //= Filter active
    10 => fact10,  //= Filter active
    11 => fact11,  //= Filter active
    12 => fact12,  //= Filter active
    13 => fact13,  //= Filter active
  },
  0x240 => reg32 f0r1 {  //! Filter bank 0 register 1
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x244 => reg32 f0r2 {  //! Filter bank 0 register 2
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x248 => reg32 f1r1 {  //! Filter bank 1 register 1
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x24c => reg32 f1r2 {  //! Filter bank 1 register 2
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x250 => reg32 f2r1 {  //! Filter bank 2 register 1
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x254 => reg32 f2r2 {  //! Filter bank 2 register 2
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x258 => reg32 f3r1 {  //! Filter bank 3 register 1
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x25c => reg32 f3r2 {  //! Filter bank 3 register 2
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x260 => reg32 f4r1 {  //! Filter bank 4 register 1
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x264 => reg32 f4r2 {  //! Filter bank 4 register 2
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x268 => reg32 f5r1 {  //! Filter bank 5 register 1
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x26c => reg32 f5r2 {  //! Filter bank 5 register 2
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x270 => reg32 f6r1 {  //! Filter bank 6 register 1
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x274 => reg32 f6r2 {  //! Filter bank 6 register 2
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x278 => reg32 f7r1 {  //! Filter bank 7 register 1
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x27c => reg32 f7r2 {  //! Filter bank 7 register 2
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x280 => reg32 f8r1 {  //! Filter bank 8 register 1
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x284 => reg32 f8r2 {  //! Filter bank 8 register 2
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x288 => reg32 f9r1 {  //! Filter bank 9 register 1
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x28c => reg32 f9r2 {  //! Filter bank 9 register 2
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x290 => reg32 f10r1 {  //! Filter bank 10 register 1
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x294 => reg32 f10r2 {  //! Filter bank 10 register 2
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x298 => reg32 f11r1 {  //! Filter bank 11 register 1
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x29c => reg32 f11r2 {  //! Filter bank 11 register 2
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x2a0 => reg32 f12r1 {  //! Filter bank 4 register 1
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x2a4 => reg32 f12r2 {  //! Filter bank 12 register 2
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x2a8 => reg32 f13r1 {  //! Filter bank 13 register 1
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
  0x2ac => reg32 f13r2 {  //! Filter bank 13 register 2
    0 => fb0,  //= Filter bits
    1 => fb1,  //= Filter bits
    2 => fb2,  //= Filter bits
    3 => fb3,  //= Filter bits
    4 => fb4,  //= Filter bits
    5 => fb5,  //= Filter bits
    6 => fb6,  //= Filter bits
    7 => fb7,  //= Filter bits
    8 => fb8,  //= Filter bits
    9 => fb9,  //= Filter bits
    10 => fb10,  //= Filter bits
    11 => fb11,  //= Filter bits
    12 => fb12,  //= Filter bits
    13 => fb13,  //= Filter bits
    14 => fb14,  //= Filter bits
    15 => fb15,  //= Filter bits
    16 => fb16,  //= Filter bits
    17 => fb17,  //= Filter bits
    18 => fb18,  //= Filter bits
    19 => fb19,  //= Filter bits
    20 => fb20,  //= Filter bits
    21 => fb21,  //= Filter bits
    22 => fb22,  //= Filter bits
    23 => fb23,  //= Filter bits
    24 => fb24,  //= Filter bits
    25 => fb25,  //= Filter bits
    26 => fb26,  //= Filter bits
    27 => fb27,  //= Filter bits
    28 => fb28,  //= Filter bits
    29 => fb29,  //= Filter bits
    30 => fb30,  //= Filter bits
    31 => fb31,  //= Filter bits
  },
});
ioregs! (DAC @ 0x40007400 = {  //! Digital to analog converter
  0x00 => reg32 cr {  //! Control register (DAC_CR)
    0 => en1,  //= DAC channel1 enable
    1 => boff1,  //= DAC channel1 output buffer               disable
    2 => ten1,  //= DAC channel1 trigger               enable
    5..3 => tsel1,  //= DAC channel1 trigger               selection
    7..6 => wave1,  //= DAC channel1 noise/triangle wave               generation enable
    11..8 => mamp1,  //= DAC channel1 mask/amplitude               selector
    12 => dmaen1,  //= DAC channel1 DMA enable
    16 => en2,  //= DAC channel2 enable
    17 => boff2,  //= DAC channel2 output buffer               disable
    18 => ten2,  //= DAC channel2 trigger               enable
    21..19 => tsel2,  //= DAC channel2 trigger               selection
    23..22 => wave2,  //= DAC channel2 noise/triangle wave               generation enable
    27..24 => mamp2,  //= DAC channel2 mask/amplitude               selector
    28 => dmaen2,  //= DAC channel2 DMA enable
  },
  0x04 => reg32 swtrigr {  //! DAC software trigger register           (DAC_SWTRIGR)
    0 => swtrig1: wo,  //= DAC channel1 software               trigger
    1 => swtrig2: wo,  //= DAC channel2 software               trigger
  },
  0x08 => reg32 dhr12r1 {  //! DAC channel1 12-bit right-aligned data           holding register(DAC_DHR12R1)
    11..0 => dacc1dhr,  //= DAC channel1 12-bit right-aligned               data
  },
  0x0c => reg32 dhr12l1 {  //! DAC channel1 12-bit left aligned data           holding register (DAC_DHR12L1)
    15..4 => dacc1dhr,  //= DAC channel1 12-bit left-aligned               data
  },
  0x10 => reg32 dhr8r1 {  //! DAC channel1 8-bit right aligned data           holding register (DAC_DHR8R1)
    7..0 => dacc1dhr,  //= DAC channel1 8-bit right-aligned               data
  },
  0x14 => reg32 dhr12r2 {  //! DAC channel2 12-bit right aligned data           holding register (DAC_DHR12R2)
    11..0 => dacc2dhr,  //= DAC channel2 12-bit right-aligned               data
  },
  0x18 => reg32 dhr12l2 {  //! DAC channel2 12-bit left aligned data           holding register (DAC_DHR12L2)
    15..4 => dacc2dhr,  //= DAC channel2 12-bit left-aligned               data
  },
  0x1c => reg32 dhr8r2 {  //! DAC channel2 8-bit right-aligned data           holding register (DAC_DHR8R2)
    7..0 => dacc2dhr,  //= DAC channel2 8-bit right-aligned               data
  },
  0x20 => reg32 dhr12rd {  //! Dual DAC 12-bit right-aligned data holding           register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12           Reserved
    11..0 => dacc1dhr,  //= DAC channel1 12-bit right-aligned               data
    27..16 => dacc2dhr,  //= DAC channel2 12-bit right-aligned               data
  },
  0x24 => reg32 dhr12ld {  //! DUAL DAC 12-bit left aligned data holding           register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0           Reserved
    15..4 => dacc1dhr,  //= DAC channel1 12-bit left-aligned               data
    31..20 => dacc2dhr,  //= DAC channel2 12-bit right-aligned               data
  },
  0x28 => reg32 dhr8rd {  //! DUAL DAC 8-bit right aligned data holding           register (DAC_DHR8RD), Bits 31:16 Reserved
    7..0 => dacc1dhr,  //= DAC channel1 8-bit right-aligned               data
    15..8 => dacc2dhr,  //= DAC channel2 8-bit right-aligned               data
  },
  0x2c => reg32 dor1 {  //! DAC channel1 data output register           (DAC_DOR1)
    11..0 => dacc1dor: ro,  //= DAC channel1 data output
  },
  0x30 => reg32 dor2 {  //! DAC channel2 data output register           (DAC_DOR2)
    11..0 => dacc2dor: ro,  //= DAC channel2 data output
  },
});
ioregs! (DBG @ 0xe0042000 = {  //! Debug support
  0x00 => reg32 idcode {  //! DBGMCU_IDCODE
    11..0 => dev_id: ro,  //= DEV_ID
    31..16 => rev_id: ro,  //= REV_ID
  },
  0x04 => reg32 cr {  //! DBGMCU_CR
    0 => dbg_sleep,  //= DBG_SLEEP
    1 => dbg_stop,  //= DBG_STOP
    2 => dbg_standby,  //= DBG_STANDBY
    5 => trace_ioen,  //= TRACE_IOEN
    7..6 => trace_mode,  //= TRACE_MODE
    8 => dbg_iwdg_stop,  //= DBG_IWDG_STOP
    9 => dbg_wwdg_stop,  //= DBG_WWDG_STOP
    10 => dbg_tim1_stop,  //= DBG_TIM1_STOP
    11 => dbg_tim2_stop,  //= DBG_TIM2_STOP
    12 => dbg_tim3_stop,  //= DBG_TIM3_STOP
    13 => dbg_tim4_stop,  //= DBG_TIM4_STOP
    14 => dbg_can1_stop,  //= DBG_CAN1_STOP
    15 => dbg_i2c1_smbus_timeout,  //= DBG_I2C1_SMBUS_TIMEOUT
    16 => dbg_i2c2_smbus_timeout,  //= DBG_I2C2_SMBUS_TIMEOUT
    17 => dbg_tim8_stop,  //= DBG_TIM8_STOP
    18 => dbg_tim5_stop,  //= DBG_TIM5_STOP
    19 => dbg_tim6_stop,  //= DBG_TIM6_STOP
    20 => dbg_tim7_stop,  //= DBG_TIM7_STOP
    21 => dbg_can2_stop,  //= DBG_CAN2_STOP
  },
});
ioregs! (UART4 @ 0x40004c00 = {  //! Universal asynchronous receiver       transmitter
  0x00 => reg32 sr {  //! UART4_SR
    0 => pe: ro,  //= Parity error
    1 => fe: ro,  //= Framing error
    2 => ne: ro,  //= Noise error flag
    3 => ore: ro,  //= Overrun error
    4 => idle: ro,  //= IDLE line detected
    5 => rxne,  //= Read data register not               empty
    6 => tc,  //= Transmission complete
    7 => txe: ro,  //= Transmit data register               empty
    8 => lbd,  //= LIN break detection flag
  },
  0x04 => reg32 dr {  //! UART4_DR
    8..0 => dr,  //= DR
  },
  0x08 => reg32 brr {  //! UART4_BRR
    3..0 => div_fraction,  //= DIV_Fraction
    15..4 => div_mantissa,  //= DIV_Mantissa
  },
  0x0c => reg32 cr1 {  //! UART4_CR1
    0 => sbk,  //= Send break
    1 => rwu,  //= Receiver wakeup
    2 => re,  //= Receiver enable
    3 => te,  //= Transmitter enable
    4 => idleie,  //= IDLE interrupt enable
    5 => rxneie,  //= RXNE interrupt enable
    6 => tcie,  //= Transmission complete interrupt               enable
    7 => txeie,  //= TXE interrupt enable
    8 => peie,  //= PE interrupt enable
    9 => ps,  //= Parity selection
    10 => pce,  //= Parity control enable
    11 => wake,  //= Wakeup method
    12 => m,  //= Word length
    13 => ue,  //= USART enable
  },
  0x10 => reg32 cr2 {  //! UART4_CR2
    3..0 => add,  //= Address of the USART node
    5 => lbdl,  //= lin break detection length
    6 => lbdie,  //= LIN break detection interrupt               enable
    13..12 => stop,  //= STOP bits
    14 => linen,  //= LIN mode enable
  },
  0x14 => reg32 cr3 {  //! UART4_CR3
    0 => eie,  //= Error interrupt enable
    1 => iren,  //= IrDA mode enable
    2 => irlp,  //= IrDA low-power
    3 => hdsel,  //= Half-duplex selection
    6 => dmar,  //= DMA enable receiver
    7 => dmat,  //= DMA enable transmitter
  },
});
ioregs! (UART5 @ 0x40005000 = {  //! Universal asynchronous receiver       transmitter
  0x00 => reg32 sr {  //! UART4_SR
    0 => pe: ro,  //= PE
    1 => fe: ro,  //= FE
    2 => ne: ro,  //= NE
    3 => ore: ro,  //= ORE
    4 => idle: ro,  //= IDLE
    5 => rxne,  //= RXNE
    6 => tc,  //= TC
    7 => txe: ro,  //= TXE
    8 => lbd,  //= LBD
  },
  0x04 => reg32 dr {  //! UART4_DR
    8..0 => dr,  //= DR
  },
  0x08 => reg32 brr {  //! UART4_BRR
    3..0 => div_fraction,  //= DIV_Fraction
    15..4 => div_mantissa,  //= DIV_Mantissa
  },
  0x0c => reg32 cr1 {  //! UART4_CR1
    0 => sbk,  //= SBK
    1 => rwu,  //= RWU
    2 => re,  //= RE
    3 => te,  //= TE
    4 => idleie,  //= IDLEIE
    5 => rxneie,  //= RXNEIE
    6 => tcie,  //= TCIE
    7 => txeie,  //= TXEIE
    8 => peie,  //= PEIE
    9 => ps,  //= PS
    10 => pce,  //= PCE
    11 => wake,  //= WAKE
    12 => m,  //= M
    13 => ue,  //= UE
  },
  0x10 => reg32 cr2 {  //! UART4_CR2
    3..0 => add,  //= ADD
    5 => lbdl,  //= LBDL
    6 => lbdie,  //= LBDIE
    13..12 => stop,  //= STOP
    14 => linen,  //= LINEN
  },
  0x14 => reg32 cr3 {  //! UART4_CR3
    0 => eie,  //= Error interrupt enable
    1 => iren,  //= IrDA mode enable
    2 => irlp,  //= IrDA low-power
    3 => hdsel,  //= Half-duplex selection
    7 => dmat,  //= DMA enable transmitter
  },
});
ioregs! (CRC @ 0x40023000 = {  //! CRC calculation unit
  0x00 => reg32 dr {  //! Data register
    31..0 => dr,  //= Data Register
  },
  0x04 => reg32 idr {  //! Independent Data register
    7..0 => idr,  //= Independent Data register
  },
  0x08 => reg32 cr {  //! Control register
    0 => reset: wo,  //= Reset bit
  },
});
ioregs! (FLASH @ 0x40022000 = {  //! FLASH
  0x00 => reg32 acr {  //! Flash access control register
    2..0 => latency,  //= Latency
    3 => hlfcya,  //= Flash half cycle access               enable
    4 => prftbe,  //= Prefetch buffer enable
    5 => prftbs: ro,  //= Prefetch buffer status
  },
  0x04 => reg32 keyr {  //! Flash key register
    31..0 => key: wo,  //= FPEC key
  },
  0x08 => reg32 optkeyr {  //! Flash option key register
    31..0 => optkey: wo,  //= Option byte key
  },
  0x0c => reg32 sr {  //! Status register
    5 => eop,  //= End of operation
    4 => wrprterr,  //= Write protection error
    2 => pgerr,  //= Programming error
    0 => bsy: ro,  //= Busy
  },
  0x10 => reg32 cr {  //! Control register
    0 => pg,  //= Programming
    1 => per,  //= Page Erase
    2 => mer,  //= Mass Erase
    4 => optpg,  //= Option byte programming
    5 => opter,  //= Option byte erase
    6 => strt,  //= Start
    7 => lock,  //= Lock
    9 => optwre,  //= Option bytes write enable
    10 => errie,  //= Error interrupt enable
    12 => eopie,  //= End of operation interrupt               enable
  },
  0x14 => reg32 ar {  //! Flash address register
    31..0 => far: wo,  //= Flash Address
  },
  0x1c => reg32 obr {  //! Option byte register
    0 => opterr: ro,  //= Option byte error
    1 => rdprt: ro,  //= Read protection
    2 => wdg_sw: ro,  //= WDG_SW
    3 => nrst_stop: ro,  //= nRST_STOP
    4 => nrst_stdby: ro,  //= nRST_STDBY
    17..10 => data0: ro,  //= Data0
    25..18 => data1: ro,  //= Data1
  },
  0x20 => reg32 wrpr {  //! Write protection register
    31..0 => wrp: ro,  //= Write protect
  },
});
ioregs! (NVIC @ 0xe000e000 = {  //! Nested Vectored Interrupt       Controller
  0x04 => reg32 ictr {  //! Interrupt Controller Type           Register
    3..0 => intlinesnum: ro,  //= Total number of interrupt lines in               groups
  },
  0xf00 => reg32 stir {  //! Software Triggered Interrupt           Register
    8..0 => intid: wo,  //= interrupt to be triggered
  },
  0x100 => reg32 iser0 {  //! Interrupt Set-Enable Register
    31..0 => setena,  //= SETENA
  },
  0x104 => reg32 iser1 {  //! Interrupt Set-Enable Register
    31..0 => setena,  //= SETENA
  },
  0x180 => reg32 icer0 {  //! Interrupt Clear-Enable           Register
    31..0 => clrena,  //= CLRENA
  },
  0x184 => reg32 icer1 {  //! Interrupt Clear-Enable           Register
    31..0 => clrena,  //= CLRENA
  },
  0x200 => reg32 ispr0 {  //! Interrupt Set-Pending Register
    31..0 => setpend,  //= SETPEND
  },
  0x204 => reg32 ispr1 {  //! Interrupt Set-Pending Register
    31..0 => setpend,  //= SETPEND
  },
  0x280 => reg32 icpr0 {  //! Interrupt Clear-Pending           Register
    31..0 => clrpend,  //= CLRPEND
  },
  0x284 => reg32 icpr1 {  //! Interrupt Clear-Pending           Register
    31..0 => clrpend,  //= CLRPEND
  },
  0x300 => reg32 iabr0 {  //! Interrupt Active Bit Register
    31..0 => active: ro,  //= ACTIVE
  },
  0x304 => reg32 iabr1 {  //! Interrupt Active Bit Register
    31..0 => active: ro,  //= ACTIVE
  },
  0x400 => reg32 ipr0 {  //! Interrupt Priority Register
    7..0 => ipr_n0,  //= IPR_N0
    15..8 => ipr_n1,  //= IPR_N1
    23..16 => ipr_n2,  //= IPR_N2
    31..24 => ipr_n3,  //= IPR_N3
  },
  0x404 => reg32 ipr1 {  //! Interrupt Priority Register
    7..0 => ipr_n0,  //= IPR_N0
    15..8 => ipr_n1,  //= IPR_N1
    23..16 => ipr_n2,  //= IPR_N2
    31..24 => ipr_n3,  //= IPR_N3
  },
  0x408 => reg32 ipr2 {  //! Interrupt Priority Register
    7..0 => ipr_n0,  //= IPR_N0
    15..8 => ipr_n1,  //= IPR_N1
    23..16 => ipr_n2,  //= IPR_N2
    31..24 => ipr_n3,  //= IPR_N3
  },
  0x40c => reg32 ipr3 {  //! Interrupt Priority Register
    7..0 => ipr_n0,  //= IPR_N0
    15..8 => ipr_n1,  //= IPR_N1
    23..16 => ipr_n2,  //= IPR_N2
    31..24 => ipr_n3,  //= IPR_N3
  },
  0x410 => reg32 ipr4 {  //! Interrupt Priority Register
    7..0 => ipr_n0,  //= IPR_N0
    15..8 => ipr_n1,  //= IPR_N1
    23..16 => ipr_n2,  //= IPR_N2
    31..24 => ipr_n3,  //= IPR_N3
  },
  0x414 => reg32 ipr5 {  //! Interrupt Priority Register
    7..0 => ipr_n0,  //= IPR_N0
    15..8 => ipr_n1,  //= IPR_N1
    23..16 => ipr_n2,  //= IPR_N2
    31..24 => ipr_n3,  //= IPR_N3
  },
  0x418 => reg32 ipr6 {  //! Interrupt Priority Register
    7..0 => ipr_n0,  //= IPR_N0
    15..8 => ipr_n1,  //= IPR_N1
    23..16 => ipr_n2,  //= IPR_N2
    31..24 => ipr_n3,  //= IPR_N3
  },
  0x41c => reg32 ipr7 {  //! Interrupt Priority Register
    7..0 => ipr_n0,  //= IPR_N0
    15..8 => ipr_n1,  //= IPR_N1
    23..16 => ipr_n2,  //= IPR_N2
    31..24 => ipr_n3,  //= IPR_N3
  },
  0x420 => reg32 ipr8 {  //! Interrupt Priority Register
    7..0 => ipr_n0,  //= IPR_N0
    15..8 => ipr_n1,  //= IPR_N1
    23..16 => ipr_n2,  //= IPR_N2
    31..24 => ipr_n3,  //= IPR_N3
  },
  0x424 => reg32 ipr9 {  //! Interrupt Priority Register
    7..0 => ipr_n0,  //= IPR_N0
    15..8 => ipr_n1,  //= IPR_N1
    23..16 => ipr_n2,  //= IPR_N2
    31..24 => ipr_n3,  //= IPR_N3
  },
  0x428 => reg32 ipr10 {  //! Interrupt Priority Register
    7..0 => ipr_n0,  //= IPR_N0
    15..8 => ipr_n1,  //= IPR_N1
    23..16 => ipr_n2,  //= IPR_N2
    31..24 => ipr_n3,  //= IPR_N3
  },
  0x42c => reg32 ipr11 {  //! Interrupt Priority Register
    7..0 => ipr_n0,  //= IPR_N0
    15..8 => ipr_n1,  //= IPR_N1
    23..16 => ipr_n2,  //= IPR_N2
    31..24 => ipr_n3,  //= IPR_N3
  },
  0x430 => reg32 ipr12 {  //! Interrupt Priority Register
    7..0 => ipr_n0,  //= IPR_N0
    15..8 => ipr_n1,  //= IPR_N1
    23..16 => ipr_n2,  //= IPR_N2
    31..24 => ipr_n3,  //= IPR_N3
  },
  0x434 => reg32 ipr13 {  //! Interrupt Priority Register
    7..0 => ipr_n0,  //= IPR_N0
    15..8 => ipr_n1,  //= IPR_N1
    23..16 => ipr_n2,  //= IPR_N2
    31..24 => ipr_n3,  //= IPR_N3
  },
  0x438 => reg32 ipr14 {  //! Interrupt Priority Register
    7..0 => ipr_n0,  //= IPR_N0
    15..8 => ipr_n1,  //= IPR_N1
    23..16 => ipr_n2,  //= IPR_N2
    31..24 => ipr_n3,  //= IPR_N3
  },
});
ioregs! (USB @ 0x40005c00 = {  //! Universal serial bus full-speed device       interface
  0x00 => reg32 ep0r {  //! endpoint 0 register
    3..0 => ea,  //= Endpoint address
    5..4 => stat_tx,  //= Status bits, for transmission               transfers
    6 => dtog_tx,  //= Data Toggle, for transmission               transfers
    7 => ctr_tx,  //= Correct Transfer for               transmission
    8 => ep_kind,  //= Endpoint kind
    10..9 => ep_type,  //= Endpoint type
    11 => setup,  //= Setup transaction               completed
    13..12 => stat_rx,  //= Status bits, for reception               transfers
    14 => dtog_rx,  //= Data Toggle, for reception               transfers
    15 => ctr_rx,  //= Correct transfer for               reception
  },
  0x04 => reg32 ep1r {  //! endpoint 1 register
    3..0 => ea,  //= Endpoint address
    5..4 => stat_tx,  //= Status bits, for transmission               transfers
    6 => dtog_tx,  //= Data Toggle, for transmission               transfers
    7 => ctr_tx,  //= Correct Transfer for               transmission
    8 => ep_kind,  //= Endpoint kind
    10..9 => ep_type,  //= Endpoint type
    11 => setup,  //= Setup transaction               completed
    13..12 => stat_rx,  //= Status bits, for reception               transfers
    14 => dtog_rx,  //= Data Toggle, for reception               transfers
    15 => ctr_rx,  //= Correct transfer for               reception
  },
  0x08 => reg32 ep2r {  //! endpoint 2 register
    3..0 => ea,  //= Endpoint address
    5..4 => stat_tx,  //= Status bits, for transmission               transfers
    6 => dtog_tx,  //= Data Toggle, for transmission               transfers
    7 => ctr_tx,  //= Correct Transfer for               transmission
    8 => ep_kind,  //= Endpoint kind
    10..9 => ep_type,  //= Endpoint type
    11 => setup,  //= Setup transaction               completed
    13..12 => stat_rx,  //= Status bits, for reception               transfers
    14 => dtog_rx,  //= Data Toggle, for reception               transfers
    15 => ctr_rx,  //= Correct transfer for               reception
  },
  0x0c => reg32 ep3r {  //! endpoint 3 register
    3..0 => ea,  //= Endpoint address
    5..4 => stat_tx,  //= Status bits, for transmission               transfers
    6 => dtog_tx,  //= Data Toggle, for transmission               transfers
    7 => ctr_tx,  //= Correct Transfer for               transmission
    8 => ep_kind,  //= Endpoint kind
    10..9 => ep_type,  //= Endpoint type
    11 => setup,  //= Setup transaction               completed
    13..12 => stat_rx,  //= Status bits, for reception               transfers
    14 => dtog_rx,  //= Data Toggle, for reception               transfers
    15 => ctr_rx,  //= Correct transfer for               reception
  },
  0x10 => reg32 ep4r {  //! endpoint 4 register
    3..0 => ea,  //= Endpoint address
    5..4 => stat_tx,  //= Status bits, for transmission               transfers
    6 => dtog_tx,  //= Data Toggle, for transmission               transfers
    7 => ctr_tx,  //= Correct Transfer for               transmission
    8 => ep_kind,  //= Endpoint kind
    10..9 => ep_type,  //= Endpoint type
    11 => setup,  //= Setup transaction               completed
    13..12 => stat_rx,  //= Status bits, for reception               transfers
    14 => dtog_rx,  //= Data Toggle, for reception               transfers
    15 => ctr_rx,  //= Correct transfer for               reception
  },
  0x14 => reg32 ep5r {  //! endpoint 5 register
    3..0 => ea,  //= Endpoint address
    5..4 => stat_tx,  //= Status bits, for transmission               transfers
    6 => dtog_tx,  //= Data Toggle, for transmission               transfers
    7 => ctr_tx,  //= Correct Transfer for               transmission
    8 => ep_kind,  //= Endpoint kind
    10..9 => ep_type,  //= Endpoint type
    11 => setup,  //= Setup transaction               completed
    13..12 => stat_rx,  //= Status bits, for reception               transfers
    14 => dtog_rx,  //= Data Toggle, for reception               transfers
    15 => ctr_rx,  //= Correct transfer for               reception
  },
  0x18 => reg32 ep6r {  //! endpoint 6 register
    3..0 => ea,  //= Endpoint address
    5..4 => stat_tx,  //= Status bits, for transmission               transfers
    6 => dtog_tx,  //= Data Toggle, for transmission               transfers
    7 => ctr_tx,  //= Correct Transfer for               transmission
    8 => ep_kind,  //= Endpoint kind
    10..9 => ep_type,  //= Endpoint type
    11 => setup,  //= Setup transaction               completed
    13..12 => stat_rx,  //= Status bits, for reception               transfers
    14 => dtog_rx,  //= Data Toggle, for reception               transfers
    15 => ctr_rx,  //= Correct transfer for               reception
  },
  0x1c => reg32 ep7r {  //! endpoint 7 register
    3..0 => ea,  //= Endpoint address
    5..4 => stat_tx,  //= Status bits, for transmission               transfers
    6 => dtog_tx,  //= Data Toggle, for transmission               transfers
    7 => ctr_tx,  //= Correct Transfer for               transmission
    8 => ep_kind,  //= Endpoint kind
    10..9 => ep_type,  //= Endpoint type
    11 => setup,  //= Setup transaction               completed
    13..12 => stat_rx,  //= Status bits, for reception               transfers
    14 => dtog_rx,  //= Data Toggle, for reception               transfers
    15 => ctr_rx,  //= Correct transfer for               reception
  },
  0x40 => reg32 cntr {  //! control register
    0 => fres,  //= Force USB Reset
    1 => pdwn,  //= Power down
    2 => lpmode,  //= Low-power mode
    3 => fsusp,  //= Force suspend
    4 => resume,  //= Resume request
    8 => esofm,  //= Expected start of frame interrupt               mask
    9 => sofm,  //= Start of frame interrupt               mask
    10 => resetm,  //= USB reset interrupt mask
    11 => suspm,  //= Suspend mode interrupt               mask
    12 => wkupm,  //= Wakeup interrupt mask
    13 => errm,  //= Error interrupt mask
    14 => pmaovrm,  //= Packet memory area over / underrun               interrupt mask
    15 => ctrm,  //= Correct transfer interrupt               mask
  },
  0x44 => reg32 istr {  //! interrupt status register
    3..0 => ep_id,  //= Endpoint Identifier
    4 => dir,  //= Direction of transaction
    8 => esof,  //= Expected start frame
    9 => sof,  //= start of frame
    10 => reset,  //= reset request
    11 => susp,  //= Suspend mode request
    12 => wkup,  //= Wakeup
    13 => err,  //= Error
    14 => pmaovr,  //= Packet memory area over /               underrun
    15 => ctr,  //= Correct transfer
  },
  0x48 => reg32 fnr {  //! frame number register
    10..0 => fn: ro,  //= Frame number
    12..11 => lsof: ro,  //= Lost SOF
    13 => lck: ro,  //= Locked
    14 => rxdm: ro,  //= Receive data - line status
    15 => rxdp: ro,  //= Receive data + line status
  },
  0x4c => reg32 daddr {  //! device address
    6..0 => add,  //= Device address
    7 => ef,  //= Enable function
  },
  0x50 => reg32 btable {  //! Buffer table address
    15..3 => btable,  //= Buffer table
  },
});
